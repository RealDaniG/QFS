# V13.6 Circular Import Remediation Plan
**Status:** Blocking V13.6 Test Execution  
**Severity:** HIGH (blocks evidence generation)  
**Evidence Principle:** Tests cannot run → no legitimate evidence can be generated → must fix imports first

---

## Problem Statement

The V13.6 test suite infrastructure is **architecturally sound** but **cannot execute** due to circular imports in the governance module layer:

```
Chain 1: NODAllocator ↔ NODInvariantChecker
  - NODAllocator imports NODInvariantChecker to validate allocations
  - NODInvariantChecker imports NODAllocator for type definitions
  - Result: ModuleNotFoundError on import

Chain 2: EconomicsGuard ↔ NODAllocator / NODInvariantChecker
  - EconomicsGuard needs both for cross-guard validation
  - Both need EconomicsGuard for error codes and constants
  - Result: Circular dependency blocks import

Chain 3: StateTransitionEngine → (Chain 1 + Chain 2)
  - StateTransitionEngine depends on all above for atomic state mutations
  - Result: Cascading import failure blocks all four V13.6 test suites
```

**Current Error:**
```
ImportError: cannot import name 'NODAllocator' from partially initialized module 
'src.libs.governance.NODAllocator' (most likely due to a circular import)
```

**Impact:**
- ❌ DeterministicReplayTest cannot run
- ❌ BoundaryConditionTests cannot run
- ❌ FailureModeTests cannot run
- ❌ PerformanceBenchmark cannot run
- ❌ CIR-302 integration testing blocked
- ❌ Autonomous audit v2.0 blocked
- ❌ No legitimate evidence can be generated

---

## Root Cause Analysis

### Dependency Graph (Current - Broken)

```
StateTransitionEngine
├─ EconomicsGuard
│  ├─ NODInvariantChecker ← (wants NODAllocator)
│  │  └─ NODAllocator ← (wants NODInvariantChecker)
│  └─ economic_constants
└─ NODAllocator ← (imported above, circular)
```

### Why It Happens

**NODAllocator.py (line ~70):**
```python
from src.libs.governance.NODInvariantChecker import NODInvariantChecker
# Wants to call NODInvariantChecker.check_allocation_invariants()
```

**NODInvariantChecker.py (line ~29):**
```python
from src.libs.governance.NODAllocator import NODAllocator
# Wants type: NODAllocator for type hints or access to NODAllocation dataclass
```

**Result:** Python tries to import A, A tries to import B, B tries to import A → circular.

---

## Refactoring Strategy

### Option A: Lazy Imports (Recommended - Low Risk)

**Effort:** 2–3 hours  
**Risk:** Very Low  
**Approach:** Move imports to function scope where they're actually needed.

**Example:**

```python
# NODAllocator.py (BEFORE - circular)
from src.libs.governance.NODInvariantChecker import NODInvariantChecker

def allocate_nod(...):
    checker = NODInvariantChecker(...)
    # ...

# NODAllocator.py (AFTER - lazy import)
def allocate_nod(...):
    from src.libs.governance.NODInvariantChecker import NODInvariantChecker
    checker = NODInvariantChecker(...)
    # ...
```

**Rationale:** Import is only needed at runtime in `allocate_nod()`, not at module load. Lazy import breaks the cycle because NODInvariantChecker loads first, then when it imports NODAllocator, NODAllocator is already partially initialized.

**Files to refactor:**
1. `src/libs/governance/NODAllocator.py` - move NODInvariantChecker import to function scope
2. `src/libs/governance/NODInvariantChecker.py` - move NODAllocator import to function scope (if used for type hints, use TYPE_CHECKING)
3. `src/libs/integration/StateTransitionEngine.py` - use lazy imports for the above two

---

### Option B: Type Annotations + TYPE_CHECKING (Alternative - Very Low Risk)

**Effort:** 1–2 hours  
**Risk:** Minimal  
**Approach:** Use Python's `TYPE_CHECKING` for type hints, avoid runtime imports of the circular module.

**Example:**

```python
# NODInvariantChecker.py (BEFORE - circular at runtime)
from src.libs.governance.NODAllocator import NODAllocator

def check_allocation_invariants(allocator: NODAllocator):
    # ...

# NODInvariantChecker.py (AFTER - no runtime import)
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from src.libs.governance.NODAllocator import NODAllocator

def check_allocation_invariants(allocator: 'NODAllocator'):
    # Type hint as string; no runtime import
    # ...
```

**Rationale:** Type checkers (mypy, pyright) understand `TYPE_CHECKING` blocks; Python runtime skips them, avoiding circular imports at runtime.

**Files to refactor:**
1. `src/libs/governance/NODInvariantChecker.py` - replace NODAllocator import with TYPE_CHECKING
2. `src/libs/governance/NODAllocator.py` - replace NODInvariantChecker type hints with strings if only used in signatures
3. `src/libs/integration/StateTransitionEngine.py` - import both directly (no longer circular)

---

### Option C: Shared Types Module (More Structural - Higher Effort)

**Effort:** 3–4 hours  
**Risk:** Low (but requires structural changes)  
**Approach:** Extract shared type definitions (e.g., `NODAllocation`, `AllocationResult`) into a neutral module.

**Example:**

```
src/libs/governance/
├─ types.py                      (NEW - shared type definitions)
├─ NODAllocator.py               (imports from types, NOT NODInvariantChecker)
├─ NODInvariantChecker.py        (imports from types, NOT NODAllocator)
└─ EconomicsGuard.py             (imports from types)
```

**Rationale:** Each module imports from `types.py` (no circular), types module is dependency-neutral. Eliminates cross-module type dependencies.

**Files to refactor:**
1. Create `src/libs/governance/types.py` with all shared dataclasses
2. Update NODAllocator, NODInvariantChecker, EconomicsGuard to import from types
3. Remove circular imports between these three

---

## Detailed Refactoring Steps (Option A - Recommended)

### Step 1: Identify all circular imports

**Command:**
```bash
python -m py_compile src/libs/governance/NODAllocator.py 2>&1 | head -20
python -m py_compile src/libs/governance/NODInvariantChecker.py 2>&1 | head -20
```

**Expected output:** Shows exact line numbers of problematic imports.

### Step 2: Refactor NODAllocator.py

**Current (line ~70):**
```python
from src.libs.governance.NODInvariantChecker import NODInvariantChecker
```

**Action:** Remove module-level import, move to function scope:

```python
# At top of file, add comment:
# NODInvariantChecker imported locally in allocate_nod() to avoid circular import

def allocate_nod(...):
    from src.libs.governance.NODInvariantChecker import NODInvariantChecker
    checker = NODInvariantChecker(self.cm)
    # rest of function unchanged
```

### Step 3: Refactor NODInvariantChecker.py

**Current (line ~29):**
```python
from src.libs.governance.NODAllocator import NODAllocator
```

**Action:** Replace with TYPE_CHECKING if only used in type hints, or lazy import if used at runtime:

```python
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from src.libs.governance.NODAllocator import NODAllocator

# Change type hints to strings:
def check_allocation_invariants(allocator: 'NODAllocator') -> InvariantCheckResult:
    # No runtime import needed
```

### Step 4: Refactor StateTransitionEngine.py

**Current:**
```python
from src.libs.governance.NODAllocator import NODAllocator
from src.libs.governance.NODInvariantChecker import NODInvariantChecker
from src.libs.economics.EconomicsGuard import EconomicsGuard
```

**Action:** Use lazy imports for the guard stack:

```python
def apply_state_transition(...):
    from src.libs.governance.NODAllocator import NODAllocator
    from src.libs.governance.NODInvariantChecker import NODInvariantChecker
    from src.libs.economics.EconomicsGuard import EconomicsGuard
    
    # Rest of method unchanged
```

### Step 5: Test imports

**Command:**
```bash
python -c "from src.libs.governance.NODAllocator import NODAllocator; print('✅ NODAllocator imports OK')"
python -c "from src.libs.governance.NODInvariantChecker import NODInvariantChecker; print('✅ NODInvariantChecker imports OK')"
python -c "from src.libs.integration.StateTransitionEngine import StateTransitionEngine; print('✅ StateTransitionEngine imports OK')"
```

**Expected:** All three print success messages.

### Step 6: Run V13.6 tests

**Command:**
```bash
$env:PYTHONHASHSEED="0"; $env:TZ="UTC"
python tests/v13_6/DeterministicReplayTest.py
python tests/v13_6/BoundaryConditionTests.py
python tests/v13_6/FailureModeTests.py
python tests/v13_6/PerformanceBenchmark.py
```

**Expected:** Tests execute and generate real evidence artifacts.

---

## Files to Modify

| File | Current Issue | Action | Est. Time |
|------|--------------|--------|-----------|
| `src/libs/governance/NODAllocator.py` | Line ~70: circular import of NODInvariantChecker | Move import to function scope in `allocate_nod()` | 15 min |
| `src/libs/governance/NODInvariantChecker.py` | Line ~29: circular import of NODAllocator | Replace with TYPE_CHECKING block | 15 min |
| `src/libs/integration/StateTransitionEngine.py` | Depends on both above | Use lazy imports in `apply_state_transition()` | 15 min |
| `src/libs/economics/EconomicsGuard.py` | (verify no circular deps to above) | Check only; no changes expected | 5 min |
| `src/libs/governance/__init__.py` | (if it re-exports modules) | Verify exports don't trigger imports | 5 min |

**Total estimated time: 50 minutes – 1.5 hours**

---

## Success Criteria

### Import Check
```bash
python -c "from src.libs.integration.StateTransitionEngine import StateTransitionEngine; print('OK')"
```
**Expected:** No ImportError ✅

### Test Execution
```bash
python tests/v13_6/DeterministicReplayTest.py
```
**Expected:** 
- No import errors
- Test output to console
- Real evidence JSON written to `evidence/v13_6/nod_replay_determinism.json` ✅

### Evidence Generation
```bash
ls -la evidence/v13_6/
```
**Expected:**
- `nod_replay_determinism.json` - with actual test results
- `economic_bounds_verification.json` - with actual boundary test outcomes
- `failure_mode_verification.json` - with actual guard violation tests
- `performance_benchmark.json` - with actual TPS and latency measurements ✅

---

## Next Steps (After Refactoring)

1. **Run refactored tests** to generate real evidence
2. **Populate evidence artifacts** with actual test output (not mocks)
3. **Re-execute autonomous audit v2.0** with real evidence
4. **Stage and commit** with accurate evidence backing the V13.6 claims
5. **Tag v13.6.0-constitutional-integration** after all tests pass

---

## Why This Approach

✅ **Honest:** We acknowledge the blockers and fix them directly  
✅ **Evidence-First:** No fake evidence; only real test output  
✅ **Low Risk:** Lazy imports and TYPE_CHECKING are standard Python patterns  
✅ **Audit-Compliant:** Aligns with zero-simulation, determinism, and reproducibility principles  
✅ **Sustainable:** Cleaner imports benefit future phases

---

**Status:** Ready to execute refactoring.  
**Recommendation:** Start with Option A (lazy imports) — fastest, lowest risk, immediate unblock of test suites.
