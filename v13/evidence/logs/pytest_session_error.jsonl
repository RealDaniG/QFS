{"timestamp": "2025-12-15T16:27:01.345534", "session_id": "2ca08fd6a082ae9b", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_coherence_referral_integration.py::TestCoherenceReferralIntegration::test_referral_reward_application", "context": {"env": "test"}, "details": {"duration": 0.00025740000273799524, "error": "self = <v13.tests.unit.test_coherence_referral_integration.TestCoherenceReferralIntegration object at 0x000001976D983B10>\n\n    def test_referral_reward_application(self):\n        \"\"\"Test that CoherenceEngine correctly applies ReferralRewarded events to token state.\"\"\"\n        cm = CertifiedMath()\n        engine = CoherenceEngine(cm)\n    \n        # Initial State\n        referrer_wallet = \"0xReferrerWallet\"\n        initial_balance = \"100.0\"\n    \n        # Create initial bundle\n>       initial_bundle = create_token_state_bundle(\n            chr_state={},\n            flx_state={referrer_wallet: BigNum128.from_string(initial_balance)},\n            psi_sync_state={},\n            atr_state={},\n            res_state={},\n            nod_state={},\n            lambda1=BigNum128.from_int(1),\n            lambda2=BigNum128.from_int(1),\n            c_crit=BigNum128.from_int(1),\n            pqc_cid=\"test_cid\",\n            timestamp=1000\n        )\n\nv13\\tests\\unit\\test_coherence_referral_integration.py:20: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nv13\\core\\TokenStateBundle.py:463: in create_token_state_bundle\n    bundle_id = temp_bundle.get_deterministic_hash(include_signature=False)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = TokenStateBundle(chr_state={}, flx_state={'0xReferrerWallet': BigNum128(raw=100000000000000000000, fp='100.0')}, psi_s...=100000000000000000000000000, fp='100000000.0'), 'phi': BigNum128(raw=1618033988749894848, fp='1.618033988749894848')})\ninclude_signature = False\n\n    def get_deterministic_hash(self, include_signature: bool = True) -> str:\n        \"\"\"\n        Generate a deterministic SHA-256 hash of the TokenStateBundle.\n        This is used for bundle identification and integrity verification.\n    \n        Args:\n            include_signature: Whether to include the signature in the hash calculation\n    \n        Returns:\n            str: SHA-256 hash as hexadecimal string\n        \"\"\"\n>       serialized = json.dumps(self.to_dict(include_signature=include_signature), sort_keys=True, separators=(',', ':'))\n                     ^^^^\nE       NameError: name 'json' is not defined. Did you forget to import 'json'?\n\nv13\\core\\TokenStateBundle.py:381: NameError"}, "hash": "edd7d319d2c08bde4e1ee30c112bcd9d95c9bccca2315bea9aedbcc86e99f0997b835d1b19441e4971d538e9b88d60a629e4672e854440eed92140eb5841a9a7"}
{"timestamp": "2025-12-15T16:27:32.483309", "session_id": "ff13cb43b2234dda", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_coherence_referral_integration.py::TestCoherenceReferralIntegration::test_referral_reward_application", "context": {"env": "test"}, "details": {"duration": 0.00024019999909796752, "error": "self = <v13.tests.unit.test_coherence_referral_integration.TestCoherenceReferralIntegration object at 0x0000027F169BF890>\n\n    def test_referral_reward_application(self):\n        \"\"\"Test that CoherenceEngine correctly applies ReferralRewarded events to token state.\"\"\"\n        cm = CertifiedMath()\n        engine = CoherenceEngine(cm)\n    \n        # Initial State\n        referrer_wallet = \"0xReferrerWallet\"\n        initial_balance = \"100.0\"\n    \n        # Create initial bundle\n>       initial_bundle = create_token_state_bundle(\n            chr_state={},\n            flx_state={referrer_wallet: BigNum128.from_string(initial_balance)},\n            psi_sync_state={},\n            atr_state={},\n            res_state={},\n            nod_state={},\n            lambda1=BigNum128.from_int(1),\n            lambda2=BigNum128.from_int(1),\n            c_crit=BigNum128.from_int(1),\n            pqc_cid=\"test_cid\",\n            timestamp=1000\n        )\n\nv13\\tests\\unit\\test_coherence_referral_integration.py:20: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nv13\\core\\TokenStateBundle.py:463: in create_token_state_bundle\n    bundle_id = temp_bundle.get_deterministic_hash(include_signature=False)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = TokenStateBundle(chr_state={}, flx_state={'0xReferrerWallet': BigNum128(raw=100000000000000000000, fp='100.0')}, psi_s...=100000000000000000000000000, fp='100000000.0'), 'phi': BigNum128(raw=1618033988749894848, fp='1.618033988749894848')})\ninclude_signature = False\n\n    def get_deterministic_hash(self, include_signature: bool = True) -> str:\n        \"\"\"\n        Generate a deterministic SHA-256 hash of the TokenStateBundle.\n        This is used for bundle identification and integrity verification.\n    \n        Args:\n            include_signature: Whether to include the signature in the hash calculation\n    \n        Returns:\n            str: SHA-256 hash as hexadecimal string\n        \"\"\"\n>       serialized = json.dumps(self.to_dict(include_signature=include_signature), sort_keys=True, separators=(',', ':'))\n                     ^^^^\nE       NameError: name 'json' is not defined. Did you forget to import 'json'?\n\nv13\\core\\TokenStateBundle.py:381: NameError"}, "hash": "65bf6c2dbf638a8556501f192fb60d807a05a2327e29e1e5c0ba43129d33a3371b88b4b1c9266303dfdede76a1dfb4007b0839a1f936cc4adf3f219f8a143cce"}
{"timestamp": "2025-12-15T16:28:06.830187", "session_id": "b8d156f20207f4bd", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_coherence_referral_integration.py::TestCoherenceReferralIntegration::test_referral_reward_application", "context": {"env": "test"}, "details": {"duration": 0.0004907999973511323, "error": "self = <v13.tests.unit.test_coherence_referral_integration.TestCoherenceReferralIntegration object at 0x0000024993303890>\n\n    def test_referral_reward_application(self):\n        \"\"\"Test that CoherenceEngine correctly applies ReferralRewarded events to token state.\"\"\"\n        cm = CertifiedMath()\n        engine = CoherenceEngine(cm)\n    \n        # Initial State\n        referrer_wallet = \"0xReferrerWallet\"\n        initial_balance = \"100.0\"\n    \n        # Create initial bundle\n        initial_bundle = create_token_state_bundle(\n            chr_state={},\n            flx_state={referrer_wallet: BigNum128.from_string(initial_balance)},\n            psi_sync_state={},\n            atr_state={},\n            res_state={},\n            nod_state={},\n            lambda1=BigNum128.from_int(1),\n            lambda2=BigNum128.from_int(1),\n            c_crit=BigNum128.from_int(1),\n            pqc_cid=\"test_cid\",\n            timestamp=1000\n        )\n    \n        # Create ReferralRewarded event\n        reward_amount_scaled = 10_000_000_000 # 100 FLX (1e8 scale)\n        # Note: BigNum128 from_string(\"100.0\") is 100 * 1e18? Or 1e8?\n        # CertifiedMath/BigNum128 typically uses 1e18 or 1e9 depending on impl.\n        # The event uses 'amount_scaled' which usually implies integer units.\n        # But BigNum128.from_int(x) creates a BigNum with internal value x.\n        # If TokenState uses fixed point 1e18, we need to match.\n        # Let's assume the event amount is already in the correct \"atomic units\" for BigNum128.\n        # If BigNum128 expects 18 decimals, 100 FLX = 100 * 10^18.\n        # If ReferralLedger uses 10_000_000_000 (10^10), that might be small if 18 decimals.\n        # Let's check CertifiedMath/BigNum128 implementation if possibly, but in test we can assert the addition.\n    \n        event = ReferralRewarded(\n            referrer_wallet=referrer_wallet,\n            referee_wallet=\"0xReferee\",\n            token_type=\"FLX\",\n            amount_scaled=reward_amount_scaled,\n            epoch=101,\n            reason=\"Test Reward\",\n            guard_cir_code=\"PASS\"\n        )\n    \n        log_list = []\n    \n        # Apply transition\n        new_bundle = engine.apply_hsmf_transition(\n            current_bundle=initial_bundle,\n            log_list=log_list,\n            pqc_cid=\"test_cid_2\",\n            deterministic_timestamp=1100,\n            processed_events=[event]\n        )\n    \n        # Verify result\n        # Initial: 100.0 (BigNum128 likely parses decimal string to fixed point)\n        # Added: 10_000_000_000 (raw int)\n    \n        # We need to know what \"100.0\" becomes.\n        # If BigNum128 uses 1e18 scale: 100.0 -> 100 * 10^18 = 10^20.\n        # 10_000_000_000 is 10^10. So it is negligible.\n    \n        # HOWEVER, the ReferralLedger used 10_000_000_000 for \"100 FLX\" which implies 1e8 scale.\n        # If BigNum128 uses 1e18, then the Ledger is emitting wrong units OR BigNum128 handles it.\n        # For this test, effectively we just want to see Balance_New = Balance_Old + Reward.\n    \n        old_balance = initial_bundle.flx_state[referrer_wallet]\n        new_balance = new_bundle.flx_state[referrer_wallet]\n    \n        expected_balance = cm.add(old_balance, BigNum128.from_int(reward_amount_scaled), [])\n    \n        assert new_balance.value == expected_balance.value\n        assert new_balance.value > old_balance.value\n    \n        # Check logs\n        found_log = False\n>       for log in cm._audit_log: # Or check log_list if passed\n                   ^^^^^^^^^^^^^\nE       AttributeError: 'CertifiedMath' object has no attribute '_audit_log'\n\nv13\\tests\\unit\\test_coherence_referral_integration.py:89: AttributeError"}, "hash": "b3b2e84175d0f57c40f53848a02934f3ece2ac954b0d7a6ab33baebaf02bfaa6a13f454173a08fd1d6c18af7d1faf857d26e2695fd2c971f9d14838ad4221f60"}
{"timestamp": "2025-12-15T16:28:43.138661", "session_id": "acf666461d820285", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_coherence_referral_integration.py::TestCoherenceReferralIntegration::test_referral_reward_application", "context": {"env": "test"}, "details": {"duration": 0.0005178000028536189, "error": "self = <v13.tests.unit.test_coherence_referral_integration.TestCoherenceReferralIntegration object at 0x000002DB5873F610>\n\n    def test_referral_reward_application(self):\n        \"\"\"Test that CoherenceEngine correctly applies ReferralRewarded events to token state.\"\"\"\n        cm = CertifiedMath()\n        engine = CoherenceEngine(cm)\n    \n        # Initial State\n        referrer_wallet = \"0xReferrerWallet\"\n        initial_balance = \"100.0\"\n    \n        # Create initial bundle\n        initial_bundle = create_token_state_bundle(\n            chr_state={},\n            flx_state={referrer_wallet: BigNum128.from_string(initial_balance)},\n            psi_sync_state={},\n            atr_state={},\n            res_state={},\n            nod_state={},\n            lambda1=BigNum128.from_int(1),\n            lambda2=BigNum128.from_int(1),\n            c_crit=BigNum128.from_int(1),\n            pqc_cid=\"test_cid\",\n            timestamp=1000\n        )\n    \n        # Create ReferralRewarded event\n        reward_amount_scaled = 10_000_000_000 # 100 FLX (1e8 scale)\n        # Note: BigNum128 from_string(\"100.0\") is 100 * 1e18? Or 1e8?\n        # CertifiedMath/BigNum128 typically uses 1e18 or 1e9 depending on impl.\n        # The event uses 'amount_scaled' which usually implies integer units.\n        # But BigNum128.from_int(x) creates a BigNum with internal value x.\n        # If TokenState uses fixed point 1e18, we need to match.\n        # Let's assume the event amount is already in the correct \"atomic units\" for BigNum128.\n        # If BigNum128 expects 18 decimals, 100 FLX = 100 * 10^18.\n        # If ReferralLedger uses 10_000_000_000 (10^10), that might be small if 18 decimals.\n        # Let's check CertifiedMath/BigNum128 implementation if possibly, but in test we can assert the addition.\n    \n        event = ReferralRewarded(\n            referrer_wallet=referrer_wallet,\n            referee_wallet=\"0xReferee\",\n            token_type=\"FLX\",\n            amount_scaled=reward_amount_scaled,\n            epoch=101,\n            reason=\"Test Reward\",\n            guard_cir_code=\"PASS\"\n        )\n    \n        log_list = []\n    \n        # Apply transition\n        new_bundle = engine.apply_hsmf_transition(\n            current_bundle=initial_bundle,\n            log_list=log_list,\n            pqc_cid=\"test_cid_2\",\n            deterministic_timestamp=1100,\n            processed_events=[event]\n        )\n    \n        # Verify result\n        # Initial: 100.0 (BigNum128 likely parses decimal string to fixed point)\n        # Added: 10_000_000_000 (raw int)\n    \n        # We need to know what \"100.0\" becomes.\n        # If BigNum128 uses 1e18 scale: 100.0 -> 100 * 10^18 = 10^20.\n        # 10_000_000_000 is 10^10. So it is negligible.\n    \n        # HOWEVER, the ReferralLedger used 10_000_000_000 for \"100 FLX\" which implies 1e8 scale.\n        # If BigNum128 uses 1e18, then the Ledger is emitting wrong units OR BigNum128 handles it.\n        # For this test, effectively we just want to see Balance_New = Balance_Old + Reward.\n    \n        old_balance = initial_bundle.flx_state[referrer_wallet]\n        new_balance = new_bundle.flx_state[referrer_wallet]\n    \n        expected_balance = cm.add(old_balance, BigNum128.from_int(reward_amount_scaled), [])\n    \n        assert new_balance.value == expected_balance.value\n        assert new_balance.value > old_balance.value\n    \n        # Check logs\n        found_log = False\n        for log in log_list:\n             if log.get('operation') == 'apply_referral_reward':\n                 if log.get('input', {}).get('wallet') == referrer_wallet:\n                     found_log = True\n                     break\n    \n        # Verify that we found the log entry\n>       assert found_log, \"Referral reward application was not logged\"\nE       AssertionError: Referral reward application was not logged\nE       assert False\n\nv13\\tests\\unit\\test_coherence_referral_integration.py:96: AssertionError"}, "hash": "1ae430984d3621a973c196599be6bca61c804c6be085b7fdc7a021250941828167e86cf965e695f5b6bc4964f495fc6d100d94ff06948d5a00e9f3c4a137a260"}
{"timestamp": "2025-12-15T16:30:08.795673", "session_id": "e00392a364106388", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_coherence_referral_integration.py::TestCoherenceReferralIntegration::test_referral_reward_application", "context": {"env": "test"}, "details": {"duration": 0.000505299998621922, "error": "self = <v13.tests.unit.test_coherence_referral_integration.TestCoherenceReferralIntegration object at 0x0000019866DFF610>\n\n    def test_referral_reward_application(self):\n        \"\"\"Test that CoherenceEngine correctly applies ReferralRewarded events to token state.\"\"\"\n        cm = CertifiedMath()\n        engine = CoherenceEngine(cm)\n    \n        # Initial State\n        referrer_wallet = \"0xReferrerWallet\"\n        initial_balance = \"100.0\"\n    \n        # Create initial bundle\n        initial_bundle = create_token_state_bundle(\n            chr_state={},\n            flx_state={referrer_wallet: BigNum128.from_string(initial_balance)},\n            psi_sync_state={},\n            atr_state={},\n            res_state={},\n            nod_state={},\n            lambda1=BigNum128.from_int(1),\n            lambda2=BigNum128.from_int(1),\n            c_crit=BigNum128.from_int(1),\n            pqc_cid=\"test_cid\",\n            timestamp=1000\n        )\n    \n        # Create ReferralRewarded event\n        reward_amount_scaled = 10_000_000_000 # 100 FLX (1e8 scale)\n        # Note: BigNum128 from_string(\"100.0\") is 100 * 1e18? Or 1e8?\n        # CertifiedMath/BigNum128 typically uses 1e18 or 1e9 depending on impl.\n        # The event uses 'amount_scaled' which usually implies integer units.\n        # But BigNum128.from_int(x) creates a BigNum with internal value x.\n        # If TokenState uses fixed point 1e18, we need to match.\n        # Let's assume the event amount is already in the correct \"atomic units\" for BigNum128.\n        # If BigNum128 expects 18 decimals, 100 FLX = 100 * 10^18.\n        # If ReferralLedger uses 10_000_000_000 (10^10), that might be small if 18 decimals.\n        # Let's check CertifiedMath/BigNum128 implementation if possibly, but in test we can assert the addition.\n    \n        event = ReferralRewarded(\n            referrer_wallet=referrer_wallet,\n            referee_wallet=\"0xReferee\",\n            token_type=\"FLX\",\n            amount_scaled=reward_amount_scaled,\n            epoch=101,\n            reason=\"Test Reward\",\n            guard_cir_code=\"PASS\"\n        )\n    \n        log_list = []\n    \n        # Apply transition\n        new_bundle = engine.apply_hsmf_transition(\n            current_bundle=initial_bundle,\n            log_list=log_list,\n            pqc_cid=\"test_cid_2\",\n            deterministic_timestamp=1100,\n            processed_events=[event]\n        )\n    \n        # Verify result\n        # Initial: 100.0 (BigNum128 likely parses decimal string to fixed point)\n        # Added: 10_000_000_000 (raw int)\n    \n        # We need to know what \"100.0\" becomes.\n        # If BigNum128 uses 1e18 scale: 100.0 -> 100 * 10^18 = 10^20.\n        # 10_000_000_000 is 10^10. So it is negligible.\n    \n        # HOWEVER, the ReferralLedger used 10_000_000_000 for \"100 FLX\" which implies 1e8 scale.\n        # If BigNum128 uses 1e18, then the Ledger is emitting wrong units OR BigNum128 handles it.\n        # For this test, effectively we just want to see Balance_New = Balance_Old + Reward.\n    \n        old_balance = initial_bundle.flx_state[referrer_wallet]\n        new_balance = new_bundle.flx_state[referrer_wallet]\n    \n        expected_balance = cm.add(old_balance, BigNum128.from_int(reward_amount_scaled), [])\n    \n        assert new_balance.value == expected_balance.value\n        assert new_balance.value > old_balance.value\n    \n        # Check logs\n        found_log = False\n        for log in log_list:\n             if log.get('operation') == 'apply_referral_reward':\n                 if log.get('input', {}).get('wallet') == referrer_wallet:\n                     found_log = True\n                     break\n    \n        # Verify that we found the log entry\n>       assert found_log, \"Referral reward application was not logged\"\nE       AssertionError: Referral reward application was not logged\nE       assert False\n\nv13\\tests\\unit\\test_coherence_referral_integration.py:96: AssertionError"}, "hash": "621defe49327f15d4854e733e3e9cf090f657f2b72de2d2c1486a7795993bf8ce108b3d966334177243407fd6c6b3bae1beb4d0035fb201d527a94f78a7a0642"}
{"timestamp": "2025-12-15T16:30:43.193071", "session_id": "2ef501c60d73c9f9", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_coherence_referral_integration.py::TestCoherenceReferralIntegration::test_referral_reward_application", "context": {"env": "test"}, "details": {"duration": 0.0009042999990924727, "error": "self = <v13.tests.unit.test_coherence_referral_integration.TestCoherenceReferralIntegration object at 0x000001807829F610>\n\n    def test_referral_reward_application(self):\n        \"\"\"Test that CoherenceEngine correctly applies ReferralRewarded events to token state.\"\"\"\n        cm = CertifiedMath()\n        engine = CoherenceEngine(cm)\n    \n        # Initial State\n        referrer_wallet = \"0xReferrerWallet\"\n        initial_balance = \"100.0\"\n    \n        # Create initial bundle\n        initial_bundle = create_token_state_bundle(\n            chr_state={},\n            flx_state={referrer_wallet: BigNum128.from_string(initial_balance)},\n            psi_sync_state={},\n            atr_state={},\n            res_state={},\n            nod_state={},\n            lambda1=BigNum128.from_int(1),\n            lambda2=BigNum128.from_int(1),\n            c_crit=BigNum128.from_int(1),\n            pqc_cid=\"test_cid\",\n            timestamp=1000\n        )\n    \n        # Create ReferralRewarded event\n        reward_amount_scaled = 10_000_000_000 # 100 FLX (1e8 scale)\n        # Note: BigNum128 from_string(\"100.0\") is 100 * 1e18? Or 1e8?\n        # CertifiedMath/BigNum128 typically uses 1e18 or 1e9 depending on impl.\n        # The event uses 'amount_scaled' which usually implies integer units.\n        # But BigNum128.from_int(x) creates a BigNum with internal value x.\n        # If TokenState uses fixed point 1e18, we need to match.\n        # Let's assume the event amount is already in the correct \"atomic units\" for BigNum128.\n        # If BigNum128 expects 18 decimals, 100 FLX = 100 * 10^18.\n        # If ReferralLedger uses 10_000_000_000 (10^10), that might be small if 18 decimals.\n        # Let's check CertifiedMath/BigNum128 implementation if possibly, but in test we can assert the addition.\n    \n        event = ReferralRewarded(\n            referrer_wallet=referrer_wallet,\n            referee_wallet=\"0xReferee\",\n            token_type=\"FLX\",\n            amount_scaled=reward_amount_scaled,\n            epoch=101,\n            reason=\"Test Reward\",\n            guard_cir_code=\"PASS\"\n        )\n    \n        log_list = []\n    \n        # Apply transition\n        new_bundle = engine.apply_hsmf_transition(\n            current_bundle=initial_bundle,\n            log_list=log_list,\n            pqc_cid=\"test_cid_2\",\n            deterministic_timestamp=1100,\n            processed_events=[event]\n        )\n    \n        # Verify result\n        # Initial: 100.0 (BigNum128 likely parses decimal string to fixed point)\n        # Added: 10_000_000_000 (raw int)\n    \n        # We need to know what \"100.0\" becomes.\n        # If BigNum128 uses 1e18 scale: 100.0 -> 100 * 10^18 = 10^20.\n        # 10_000_000_000 is 10^10. So it is negligible.\n    \n        # HOWEVER, the ReferralLedger used 10_000_000_000 for \"100 FLX\" which implies 1e8 scale.\n        # If BigNum128 uses 1e18, then the Ledger is emitting wrong units OR BigNum128 handles it.\n        # For this test, effectively we just want to see Balance_New = Balance_Old + Reward.\n    \n        old_balance = initial_bundle.flx_state[referrer_wallet]\n        new_balance = new_bundle.flx_state[referrer_wallet]\n    \n        expected_balance = cm.add(old_balance, BigNum128.from_int(reward_amount_scaled), [])\n    \n        assert new_balance.value == expected_balance.value\n        assert new_balance.value > old_balance.value\n    \n        # Check logs\n        found_log = False\n        for log in log_list:\n             if log.get('operation') == 'apply_referral_reward':\n                 if log.get('input', {}).get('wallet') == referrer_wallet:\n                     found_log = True\n                     break\n    \n        # Verify that we found the log entry\n>       assert found_log, \"Referral reward application was not logged\"\nE       AssertionError: Referral reward application was not logged\nE       assert False\n\nv13\\tests\\unit\\test_coherence_referral_integration.py:96: AssertionError"}, "hash": "e4221501c1a9080cc15d183d7b292e3d46780e3fadf3e939ef94adc6ff6adb4c1f9b19540bc611a3ad4271367126db78962ed6e810c083f7a8ed3a5d42d30d91"}
{"timestamp": "2025-12-15T16:31:03.887555", "session_id": "511834d3e8061df4", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_coherence_referral_integration.py::TestCoherenceReferralIntegration::test_referral_reward_application", "context": {"env": "test"}, "details": {"duration": 0.0007608999985677656, "error": "self = <v13.tests.unit.test_coherence_referral_integration.TestCoherenceReferralIntegration object at 0x000002E54EB7EE90>\n\n    def test_referral_reward_application(self):\n        \"\"\"Test that CoherenceEngine correctly applies ReferralRewarded events to token state.\"\"\"\n        cm = CertifiedMath()\n        engine = CoherenceEngine(cm)\n    \n        # Initial State\n        referrer_wallet = \"0xReferrerWallet\"\n        initial_balance = \"100.0\"\n    \n        # Create initial bundle\n        initial_bundle = create_token_state_bundle(\n            chr_state={},\n            flx_state={referrer_wallet: BigNum128.from_string(initial_balance)},\n            psi_sync_state={},\n            atr_state={},\n            res_state={},\n            nod_state={},\n            lambda1=BigNum128.from_int(1),\n            lambda2=BigNum128.from_int(1),\n            c_crit=BigNum128.from_int(1),\n            pqc_cid=\"test_cid\",\n            timestamp=1000\n        )\n    \n        # Create ReferralRewarded event\n        reward_amount_scaled = 10_000_000_000 # 100 FLX (1e8 scale)\n        # Note: BigNum128 from_string(\"100.0\") is 100 * 1e18? Or 1e8?\n        # CertifiedMath/BigNum128 typically uses 1e18 or 1e9 depending on impl.\n        # The event uses 'amount_scaled' which usually implies integer units.\n        # But BigNum128.from_int(x) creates a BigNum with internal value x.\n        # If TokenState uses fixed point 1e18, we need to match.\n        # Let's assume the event amount is already in the correct \"atomic units\" for BigNum128.\n        # If BigNum128 expects 18 decimals, 100 FLX = 100 * 10^18.\n        # If ReferralLedger uses 10_000_000_000 (10^10), that might be small if 18 decimals.\n        # Let's check CertifiedMath/BigNum128 implementation if possibly, but in test we can assert the addition.\n    \n        event = ReferralRewarded(\n            referrer_wallet=referrer_wallet,\n            referee_wallet=\"0xReferee\",\n            token_type=\"FLX\",\n            amount_scaled=reward_amount_scaled,\n            epoch=101,\n            reason=\"Test Reward\",\n            guard_cir_code=\"PASS\"\n        )\n    \n        log_list = []\n    \n        # Apply transition\n        new_bundle = engine.apply_hsmf_transition(\n            current_bundle=initial_bundle,\n            log_list=log_list,\n            pqc_cid=\"test_cid_2\",\n            deterministic_timestamp=1100,\n            processed_events=[event]\n        )\n    \n        # Verify result\n        # Initial: 100.0 (BigNum128 likely parses decimal string to fixed point)\n        # Added: 10_000_000_000 (raw int)\n    \n        # We need to know what \"100.0\" becomes.\n        # If BigNum128 uses 1e18 scale: 100.0 -> 100 * 10^18 = 10^20.\n        # 10_000_000_000 is 10^10. So it is negligible.\n    \n        # HOWEVER, the ReferralLedger used 10_000_000_000 for \"100 FLX\" which implies 1e8 scale.\n        # If BigNum128 uses 1e18, then the Ledger is emitting wrong units OR BigNum128 handles it.\n        # For this test, effectively we just want to see Balance_New = Balance_Old + Reward.\n    \n        old_balance = initial_bundle.flx_state[referrer_wallet]\n        new_balance = new_bundle.flx_state[referrer_wallet]\n    \n        expected_balance = cm.add(old_balance, BigNum128.from_int(reward_amount_scaled), [])\n    \n        assert new_balance.value == expected_balance.value\n        assert new_balance.value > old_balance.value\n    \n        # Check logs\n        found_log = False\n        for log in log_list:\n             if log.get('operation') == 'apply_referral_reward':\n                 if log.get('input', {}).get('wallet') == referrer_wallet:\n                     found_log = True\n                     break\n    \n        # Verify that we found the log entry\n>       assert found_log, \"Referral reward application was not logged\"\nE       AssertionError: Referral reward application was not logged\nE       assert False\n\nv13\\tests\\unit\\test_coherence_referral_integration.py:96: AssertionError"}, "hash": "373064e82c38d4d7754927dfd020a8a7444b87f0c8c67f3168d11458ba096cb24df7b17de9c0e708a5a6adc7572b1b5f8ed9e0e39d296652b0e9c33854e93cb1"}
{"timestamp": "2025-12-15T16:31:44.059721", "session_id": "be3f45186196f35c", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_coherence_referral_integration.py::TestCoherenceReferralIntegration::test_referral_reward_application", "context": {"env": "test"}, "details": {"duration": 0.0009006000000226777, "error": "self = <v13.tests.unit.test_coherence_referral_integration.TestCoherenceReferralIntegration object at 0x00000274C5362E90>\n\n    def test_referral_reward_application(self):\n        \"\"\"Test that CoherenceEngine correctly applies ReferralRewarded events to token state.\"\"\"\n        cm = CertifiedMath()\n        engine = CoherenceEngine(cm)\n    \n        # Initial State\n        referrer_wallet = \"0xReferrerWallet\"\n        initial_balance = \"100.0\"\n    \n        # Create initial bundle\n        initial_bundle = create_token_state_bundle(\n            chr_state={},\n            flx_state={referrer_wallet: BigNum128.from_string(initial_balance)},\n            psi_sync_state={},\n            atr_state={},\n            res_state={},\n            nod_state={},\n            lambda1=BigNum128.from_int(1),\n            lambda2=BigNum128.from_int(1),\n            c_crit=BigNum128.from_int(1),\n            pqc_cid=\"test_cid\",\n            timestamp=1000\n        )\n    \n        # Create ReferralRewarded event\n        reward_amount_scaled = 10_000_000_000 # 100 FLX (1e8 scale)\n        # Note: BigNum128 from_string(\"100.0\") is 100 * 1e18? Or 1e8?\n        # CertifiedMath/BigNum128 typically uses 1e18 or 1e9 depending on impl.\n        # The event uses 'amount_scaled' which usually implies integer units.\n        # But BigNum128.from_int(x) creates a BigNum with internal value x.\n        # If TokenState uses fixed point 1e18, we need to match.\n        # Let's assume the event amount is already in the correct \"atomic units\" for BigNum128.\n        # If BigNum128 expects 18 decimals, 100 FLX = 100 * 10^18.\n        # If ReferralLedger uses 10_000_000_000 (10^10), that might be small if 18 decimals.\n        # Let's check CertifiedMath/BigNum128 implementation if possibly, but in test we can assert the addition.\n    \n        event = ReferralRewarded(\n            referrer_wallet=referrer_wallet,\n            referee_wallet=\"0xReferee\",\n            token_type=\"FLX\",\n            amount_scaled=reward_amount_scaled,\n            epoch=101,\n            reason=\"Test Reward\",\n            guard_cir_code=\"PASS\"\n        )\n    \n        log_list = []\n    \n        # Apply transition\n        new_bundle = engine.apply_hsmf_transition(\n            current_bundle=initial_bundle,\n            log_list=log_list,\n            pqc_cid=\"test_cid_2\",\n            deterministic_timestamp=1100,\n            processed_events=[event]\n        )\n    \n        # Verify result\n        # Initial: 100.0 (BigNum128 likely parses decimal string to fixed point)\n        # Added: 10_000_000_000 (raw int)\n    \n        # We need to know what \"100.0\" becomes.\n        # If BigNum128 uses 1e18 scale: 100.0 -> 100 * 10^18 = 10^20.\n        # 10_000_000_000 is 10^10. So it is negligible.\n    \n        # HOWEVER, the ReferralLedger used 10_000_000_000 for \"100 FLX\" which implies 1e8 scale.\n        # If BigNum128 uses 1e18, then the Ledger is emitting wrong units OR BigNum128 handles it.\n        # For this test, effectively we just want to see Balance_New = Balance_Old + Reward.\n    \n        old_balance = initial_bundle.flx_state[referrer_wallet]\n        new_balance = new_bundle.flx_state[referrer_wallet]\n    \n        expected_balance = cm.add(old_balance, BigNum128.from_int(reward_amount_scaled), [])\n    \n        assert new_balance.value == expected_balance.value\n        assert new_balance.value > old_balance.value\n    \n        # Check logs\n        found_log = False\n        for log in log_list:\n             if log.get('operation') == 'apply_referral_reward':\n                 if log.get('input', {}).get('wallet') == referrer_wallet:\n                     found_log = True\n                     break\n    \n        # Verify that we found the log entry\n>       assert found_log, \"Referral reward application was not logged\"\nE       AssertionError: Referral reward application was not logged\nE       assert False\n\nv13\\tests\\unit\\test_coherence_referral_integration.py:96: AssertionError"}, "hash": "43fe6c5578bfc7642608d3275a23fb61fe5c3a74f24d47cfea86d7d5922cdb8427c1c02d53a277f45b389a1536ef290be75bab60ad4ab8f18f704e2cb6e783c1"}
{"timestamp": "2025-12-15T16:32:23.415084", "session_id": "aefa306be4d8daf2", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_coherence_referral_integration.py::TestCoherenceReferralIntegration::test_referral_reward_application", "context": {"env": "test"}, "details": {"duration": 0.0015225000024656765, "error": "self = <v13.tests.unit.test_coherence_referral_integration.TestCoherenceReferralIntegration object at 0x0000020E5689F610>\n\n    def test_referral_reward_application(self):\n        \"\"\"Test that CoherenceEngine correctly applies ReferralRewarded events to token state.\"\"\"\n        cm = CertifiedMath()\n        engine = CoherenceEngine(cm)\n    \n        # Initial State\n        referrer_wallet = \"0xReferrerWallet\"\n        initial_balance = \"100.0\"\n    \n        # Create initial bundle\n        initial_bundle = create_token_state_bundle(\n            chr_state={},\n            flx_state={referrer_wallet: BigNum128.from_string(initial_balance)},\n            psi_sync_state={},\n            atr_state={},\n            res_state={},\n            nod_state={},\n            lambda1=BigNum128.from_int(1),\n            lambda2=BigNum128.from_int(1),\n            c_crit=BigNum128.from_int(1),\n            pqc_cid=\"test_cid\",\n            timestamp=1000\n        )\n    \n        # Create ReferralRewarded event\n        reward_amount_scaled = 10_000_000_000 # 100 FLX (1e8 scale)\n        # Note: BigNum128 from_string(\"100.0\") is 100 * 1e18? Or 1e8?\n        # CertifiedMath/BigNum128 typically uses 1e18 or 1e9 depending on impl.\n        # The event uses 'amount_scaled' which usually implies integer units.\n        # But BigNum128.from_int(x) creates a BigNum with internal value x.\n        # If TokenState uses fixed point 1e18, we need to match.\n        # Let's assume the event amount is already in the correct \"atomic units\" for BigNum128.\n        # If BigNum128 expects 18 decimals, 100 FLX = 100 * 10^18.\n        # If ReferralLedger uses 10_000_000_000 (10^10), that might be small if 18 decimals.\n        # Let's check CertifiedMath/BigNum128 implementation if possibly, but in test we can assert the addition.\n    \n        event = ReferralRewarded(\n            referrer_wallet=referrer_wallet,\n            referee_wallet=\"0xReferee\",\n            token_type=\"FLX\",\n            amount_scaled=reward_amount_scaled,\n            epoch=101,\n            reason=\"Test Reward\",\n            guard_cir_code=\"PASS\"\n        )\n    \n        log_list = []\n    \n        # Apply transition\n        new_bundle = engine.apply_hsmf_transition(\n            current_bundle=initial_bundle,\n            log_list=log_list,\n            pqc_cid=\"test_cid_2\",\n            deterministic_timestamp=1100,\n            processed_events=[event]\n        )\n    \n        # Verify result\n        # Initial: 100.0 (BigNum128 likely parses decimal string to fixed point)\n        # Added: 10_000_000_000 (raw int)\n    \n        # We need to know what \"100.0\" becomes.\n        # If BigNum128 uses 1e18 scale: 100.0 -> 100 * 10^18 = 10^20.\n        # 10_000_000_000 is 10^10. So it is negligible.\n    \n        # HOWEVER, the ReferralLedger used 10_000_000_000 for \"100 FLX\" which implies 1e8 scale.\n        # If BigNum128 uses 1e18, then the Ledger is emitting wrong units OR BigNum128 handles it.\n        # For this test, effectively we just want to see Balance_New = Balance_Old + Reward.\n    \n        old_balance = initial_bundle.flx_state[referrer_wallet]\n        new_balance = new_bundle.flx_state[referrer_wallet]\n    \n        expected_balance = cm.add(old_balance, BigNum128.from_int(reward_amount_scaled), [])\n    \n        assert new_balance.value == expected_balance.value\n        assert new_balance.value > old_balance.value\n    \n        # Check logs\n        found_log = False\n        for log in log_list:\n             if log.get('operation') == 'apply_referral_reward':\n                 if log.get('input', {}).get('wallet') == referrer_wallet:\n                     found_log = True\n                     break\n    \n        # Verify that we found the log entry\n>       assert found_log, \"Referral reward application was not logged\"\nE       AssertionError: Referral reward application was not logged\nE       assert False\n\nv13\\tests\\unit\\test_coherence_referral_integration.py:96: AssertionError"}, "hash": "3c3b8903ab48c83075b1ed068e77bab68eb59670841295da0ac3ddd32aef8a76411dc354fabc150fb9702bdaf549223060b5edde36d6232489d12f43ba49d29e"}
{"timestamp": "2025-12-15T16:34:27.128126", "session_id": "178bae76e58b427a", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/test_ast_zerosimchecker_modules.py::test_golden_files", "context": {"env": "test"}, "details": {"duration": 0.0014646999989054166, "error": "def test_golden_files():\n        \"\"\"Test the static golden files for Zero-Sim compliance.\"\"\"\n        checker = AST_ZeroSimChecker()\n        current_dir = os.path.dirname(os.path.abspath(__file__))\n    \n        pass_file = os.path.join(current_dir, \"unit\", \"zero_sim_golden_pass.py\")\n        if not os.path.exists(pass_file):\n             # Try expecting it in the same directory as this test\n             pass_file = os.path.join(current_dir, \"zero_sim_golden_pass.py\")\n             if not os.path.exists(pass_file):\n                 # Fallback to v13/tests/unit\n                 pass_file = os.path.join(current_dir, \"..\", \"unit\", \"zero_sim_golden_pass.py\")\n    \n        # Ensure file exists before testing\n        assert os.path.exists(pass_file), f\"Golden pass file not found at {pass_file}\"\n    \n        violations = checker.scan_file(pass_file)\n        assert len(violations) == 0, f\"Golden pass file has violations: {violations}\"\n    \n        fail_file = os.path.join(current_dir, \"unit\", \"zero_sim_golden_fail.py\")\n        if not os.path.exists(fail_file):\n             fail_file = os.path.join(current_dir, \"zero_sim_golden_fail.py\")\n             if not os.path.exists(fail_file):\n                 fail_file = os.path.join(current_dir, \"..\", \"unit\", \"zero_sim_golden_fail.py\")\n    \n        assert os.path.exists(fail_file), f\"Golden fail file not found at {fail_file}\"\n    \n        violations = checker.scan_file(fail_file)\n        assert len(violations) > 0, \"Golden fail file has no violations\"\n    \n        # Check for specific violations we expect\n        import_violations = [v for v in violations if v.violation_type == \"FORBIDDEN_IMPORT\"]\n        call_violations = [v for v in violations if v.violation_type == \"FORBIDDEN_CALL\"]\n    \n        assert len(import_violations) > 0, \"Golden fail file missing FORBIDDEN_IMPORT violation\"\n>       assert len(call_violations) > 0, \"Golden fail file missing FORBIDDEN_CALL violation\"\nE       AssertionError: Golden fail file missing FORBIDDEN_CALL violation\nE       assert 0 > 0\nE        +  where 0 = len([])\n\nv13\\tests\\test_ast_zerosimchecker_modules.py:182: AssertionError"}, "hash": "1f9ad35c89d51da9e401e8a6487aac9f693471a717318f445d827dd821e73ff365b240fca1adcab95c25a99276f57fb39e713237a309676057798e4caaecb83f"}
{"timestamp": "2025-12-15T16:35:01.911410", "session_id": "241564f7413d3c1c", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/test_ast_zerosimchecker_modules.py::test_golden_files", "context": {"env": "test"}, "details": {"duration": 0.0013873000025341753, "error": "def test_golden_files():\n        \"\"\"Test the static golden files for Zero-Sim compliance.\"\"\"\n        checker = AST_ZeroSimChecker()\n        current_dir = os.path.dirname(os.path.abspath(__file__))\n    \n        pass_file = os.path.join(current_dir, \"unit\", \"zero_sim_golden_pass.py\")\n        if not os.path.exists(pass_file):\n             # Try expecting it in the same directory as this test\n             pass_file = os.path.join(current_dir, \"zero_sim_golden_pass.py\")\n             if not os.path.exists(pass_file):\n                 # Fallback to v13/tests/unit\n                 pass_file = os.path.join(current_dir, \"..\", \"unit\", \"zero_sim_golden_pass.py\")\n    \n        # Ensure file exists before testing\n        assert os.path.exists(pass_file), f\"Golden pass file not found at {pass_file}\"\n    \n        violations = checker.scan_file(pass_file)\n        assert len(violations) == 0, f\"Golden pass file has violations: {violations}\"\n    \n        fail_file = os.path.join(current_dir, \"unit\", \"zero_sim_golden_fail.py\")\n        if not os.path.exists(fail_file):\n             fail_file = os.path.join(current_dir, \"zero_sim_golden_fail.py\")\n             if not os.path.exists(fail_file):\n                 fail_file = os.path.join(current_dir, \"..\", \"unit\", \"zero_sim_golden_fail.py\")\n    \n        assert os.path.exists(fail_file), f\"Golden fail file not found at {fail_file}\"\n    \n        violations = checker.scan_file(fail_file)\n        assert len(violations) > 0, \"Golden fail file has no violations\"\n    \n        # Check for specific violations we expect\n        import_violations = [v for v in violations if v.violation_type == \"FORBIDDEN_IMPORT\"]\n        call_violations = [v for v in violations if v.violation_type == \"FORBIDDEN_CALL\"]\n    \n        assert len(import_violations) > 0, \"Golden fail file missing FORBIDDEN_IMPORT violation\"\n>       assert len(call_violations) > 0, \"Golden fail file missing FORBIDDEN_CALL violation\"\nE       AssertionError: Golden fail file missing FORBIDDEN_CALL violation\nE       assert 0 > 0\nE        +  where 0 = len([])\n\nv13\\tests\\test_ast_zerosimchecker_modules.py:182: AssertionError"}, "hash": "0493d1a0a9b4768c03548548bbfed0b95e9af91589a77b5560200fdce325d2a833d656233c4785ebe928f4bf2cd6d984ba5347c4a9bbffafb786397314a701dd"}
{"timestamp": "2025-12-15T16:36:17.459824", "session_id": "b38b8e521654a4fd", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/test_ast_zerosimchecker_modules.py::test_golden_files", "context": {"env": "test"}, "details": {"duration": 0.001438600000255974, "error": "def test_golden_files():\n        \"\"\"Test the static golden files for Zero-Sim compliance.\"\"\"\n        checker = AST_ZeroSimChecker()\n        current_dir = os.path.dirname(os.path.abspath(__file__))\n        # Assuming test is in v13/tests/ and compliance is in v13/compliance/\n        # Go up one level from tests/ to v13/\n        project_root = os.path.dirname(current_dir)\n    \n        pass_file = os.path.join(project_root, \"compliance\", \"golden_pass.py\")\n    \n        # Ensure file exists before testing\n        assert os.path.exists(pass_file), f\"Golden pass file not found at {pass_file}\"\n    \n        violations = checker.scan_file(pass_file)\n        assert len(violations) == 0, f\"Golden pass file has violations: {violations}\"\n    \n        fail_file = os.path.join(project_root, \"compliance\", \"golden_fail.py\")\n    \n        assert os.path.exists(fail_file), f\"Golden fail file not found at {fail_file}\"\n    \n        violations = checker.scan_file(fail_file)\n        assert len(violations) > 0, \"Golden fail file has no violations (check if it was excluded?)\"\n    \n        # Check for specific violations we expect\n        import_violations = [v for v in violations if v.violation_type == \"FORBIDDEN_IMPORT\"]\n        call_violations = [v for v in violations if v.violation_type == \"FORBIDDEN_CALL\"]\n    \n        assert len(import_violations) > 0, \"Golden fail file missing FORBIDDEN_IMPORT violation\"\n>       assert len(call_violations) > 0, \"Golden fail file missing FORBIDDEN_CALL violation\"\nE       AssertionError: Golden fail file missing FORBIDDEN_CALL violation\nE       assert 0 > 0\nE        +  where 0 = len([])\n\nv13\\tests\\test_ast_zerosimchecker_modules.py:175: AssertionError"}, "hash": "7166accc6f11a238868d51ed3585a5e6f0993259be3a9ce457b480ee4b6e236bb5d4f527dc73d9f9bdf4d7c8cbc14b1ca5f87e5dc0e0fadd26f11b47db8a04a5"}
{"timestamp": "2025-12-15T16:37:00.894866", "session_id": "3271182855e5e8c0", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/test_ast_zerosimchecker_modules.py::test_golden_files", "context": {"env": "test"}, "details": {"duration": 0.0016199000019696541, "error": "def test_golden_files():\n        \"\"\"Test the static golden files for Zero-Sim compliance.\"\"\"\n        checker = AST_ZeroSimChecker()\n        current_dir = os.path.dirname(os.path.abspath(__file__))\n        # Assuming test is in v13/tests/ and compliance is in v13/compliance/\n        # Go up one level from tests/ to v13/\n        project_root = os.path.dirname(current_dir)\n    \n        pass_file = os.path.join(project_root, \"compliance\", \"golden_pass.py\")\n    \n        # Ensure file exists before testing\n        assert os.path.exists(pass_file), f\"Golden pass file not found at {pass_file}\"\n    \n        violations = checker.scan_file(pass_file)\n        assert len(violations) == 0, f\"Golden pass file has violations: {violations}\"\n    \n        fail_file = os.path.join(project_root, \"compliance\", \"golden_fail.py\")\n    \n        assert os.path.exists(fail_file), f\"Golden fail file not found at {fail_file}\"\n    \n        violations = checker.scan_file(fail_file)\n        print(f\"DEBUG: Scanned {fail_file}\")\n        print(f\"DEBUG: Found {len(violations)} violations: {violations}\")\n        assert len(violations) > 0, f\"Golden fail file has no violations (check if it was excluded?). Violations: {violations}\"\n    \n        # Check for specific violations we expect\n        import_violations = [v for v in violations if v.violation_type == \"FORBIDDEN_IMPORT\"]\n        call_violations = [v for v in violations if v.violation_type == \"FORBIDDEN_CALL\"]\n    \n        assert len(import_violations) > 0, \"Golden fail file missing FORBIDDEN_IMPORT violation\"\n>       assert len(call_violations) > 0, \"Golden fail file missing FORBIDDEN_CALL violation\"\nE       AssertionError: Golden fail file missing FORBIDDEN_CALL violation\nE       assert 0 > 0\nE        +  where 0 = len([])\n\nv13\\tests\\test_ast_zerosimchecker_modules.py:177: AssertionError"}, "hash": "1bfc36d7a4a3c4a328e2e57f433f4de3efe9fd9dbd3e4f23832062343542177ca271b1f2361f6b986d4278427d4a340ef41680dff6070a321c8f564198b35a2c"}
{"timestamp": "2025-12-15T16:37:45.530766", "session_id": "b6bf5684ac5f3967", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/test_ast_zerosimchecker_modules.py::test_golden_files", "context": {"env": "test"}, "details": {"duration": 0.0019815999985439703, "error": "def test_golden_files():\n        \"\"\"Test the static golden files for Zero-Sim compliance.\"\"\"\n        checker = AST_ZeroSimChecker()\n        current_dir = os.path.dirname(os.path.abspath(__file__))\n        # Assuming test is in v13/tests/ and compliance is in v13/compliance/\n        # Go up one level from tests/ to v13/\n        project_root = os.path.dirname(current_dir)\n    \n        pass_file = os.path.join(project_root, \"compliance\", \"golden_pass.py\")\n    \n        # Ensure file exists before testing\n        assert os.path.exists(pass_file), f\"Golden pass file not found at {pass_file}\"\n    \n        violations = checker.scan_file(pass_file)\n        assert len(violations) == 0, f\"Golden pass file has violations: {violations}\"\n    \n        fail_file = os.path.join(project_root, \"compliance\", \"golden_fail.py\")\n    \n        assert os.path.exists(fail_file), f\"Golden fail file not found at {fail_file}\"\n    \n        violations = checker.scan_file(fail_file)\n        with open(\"debug_test_log.txt\", \"w\") as f:\n            f.write(f\"DEBUG: Scanned {fail_file}\\n\")\n            f.write(f\"DEBUG: Found {len(violations)} violations\\n\")\n            for v in violations:\n                 f.write(f\" Violation: {v}\\n\")\n    \n        assert len(violations) > 0, f\"Golden fail file has no violations (check if it was excluded?). Violations: {violations}\"\n    \n        # Check for specific violations we expect\n        import_violations = [v for v in violations if v.violation_type == \"FORBIDDEN_IMPORT\"]\n        call_violations = [v for v in violations if v.violation_type == \"FORBIDDEN_CALL\"]\n    \n        assert len(import_violations) > 0, \"Golden fail file missing FORBIDDEN_IMPORT violation\"\n>       assert len(call_violations) > 0, \"Golden fail file missing FORBIDDEN_CALL violation\"\nE       AssertionError: Golden fail file missing FORBIDDEN_CALL violation\nE       assert 0 > 0\nE        +  where 0 = len([])\n\nv13\\tests\\test_ast_zerosimchecker_modules.py:181: AssertionError"}, "hash": "c12a54ef0d4a015e42c36310b4ded58ec7c965f6b616fa33a093744bba346c737862fccee7b58a1dacafc0c23d1222cdd15804cf937c1c706d62d62798ae9a8d"}
{"timestamp": "2025-12-15T16:58:51.263573", "session_id": "f9ecea376fe83453", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_referral_ledger_sync.py::test_referral_ledger_sync_flow", "context": {"env": "test"}, "details": {"duration": 0.004231200000504032, "error": "def test_referral_ledger_sync_flow():\n        # Setup\n        with CertifiedMath.LogContext() as log_list:\n            cm = CertifiedMath()\n    \n        coherence_ledger = CoherenceLedger(cm)\n        referral_ledger = ReferralLedger(coherence_ledger)\n    \n        referrer = \"wallet_referrer_123\"\n        referee = \"wallet_referee_456\"\n        epoch = 101\n    \n        # 1. Create Link (Synchronous)\n        code = referral_ledger.create_link(referrer, epoch, \"test_source\")\n        assert code is not None\n        assert len(coherence_ledger.ledger_entries) == 1\n        assert coherence_ledger.ledger_entries[0].entry_type == \"REFERRAL_CREATED\"\n    \n        # 2. Accept\n        referral_ledger.accept(code, referee, epoch, \"device_hash_abc\")\n        assert len(coherence_ledger.ledger_entries) == 2\n        assert coherence_ledger.ledger_entries[1].entry_type == \"REFERRAL_ACCEPTED\"\n    \n        # 3. Activate & Grant Reward\n        # Mock _count_referrals to make sure we hit a tier (e.g. 0 -> 1st referral)\n        referral_ledger._count_referrals = lambda w: 0\n    \n        referral_ledger.activate(referee, \"PROFILE_COMPLETE\", epoch)\n    \n        # Should have ACTIVATED and REWARDED events\n        assert len(coherence_ledger.ledger_entries) == 4\n        assert coherence_ledger.ledger_entries[2].entry_type == \"REFERRAL_ACTIVATED\"\n        assert coherence_ledger.ledger_entries[3].entry_type == \"REFERRAL_REWARDED\"\n    \n        reward_entry = coherence_ledger.ledger_entries[3]\n        event_data = reward_entry.data[\"event_data\"]\n        assert event_data[\"amount_scaled\"] == 10_000_000_000 # 100 FLX\n>       assert event_data[\"referrer_wallet\"] == referrer\nE       AssertionError: assert 'mock_referrer' == 'wallet_referrer_123'\nE         \nE         \u001b[0m\u001b[91m- wallet_referrer_123\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\nE         \u001b[92m+ mock_referrer\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\nv13\\tests\\unit\\test_referral_ledger_sync.py:45: AssertionError"}, "hash": "20d3f197f654b5e584d452d73f52713a91bba418d9464413b00b6aca223ff325f54efd5119b60671adb4219c9a56c2511b72dbad9e2f58573a7353410ff0a7dc"}
{"timestamp": "2025-12-15T16:59:15.000366", "session_id": "4a3210341daf2cf9", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_referral_ledger_sync.py::test_referral_ledger_sync_flow", "context": {"env": "test"}, "details": {"duration": 0.0011421999988669995, "error": "def test_referral_ledger_sync_flow():\n        # Setup\n        with CertifiedMath.LogContext() as log_list:\n            cm = CertifiedMath()\n    \n        coherence_ledger = CoherenceLedger(cm)\n        referral_ledger = ReferralLedger(coherence_ledger)\n    \n        referrer = \"wallet_referrer_123\"\n        referee = \"wallet_referee_456\"\n        epoch = 101\n    \n        # 1. Create Link (Synchronous)\n        code = referral_ledger.create_link(referrer, epoch, \"test_source\")\n        assert code is not None\n        assert len(coherence_ledger.ledger_entries) == 1\n        assert coherence_ledger.ledger_entries[0].entry_type == \"REFERRAL_CREATED\"\n    \n        # 2. Accept\n        referral_ledger.accept(code, referee, epoch, \"device_hash_abc\")\n        assert len(coherence_ledger.ledger_entries) == 2\n        assert coherence_ledger.ledger_entries[1].entry_type == \"REFERRAL_ACCEPTED\"\n    \n        # 3. Activate & Grant Reward\n        # Mock _count_referrals to make sure we hit a tier (e.g. 0 -> 1st referral)\n        referral_ledger._count_referrals = lambda w: 0\n    \n        referral_ledger.activate(referee, \"PROFILE_COMPLETE\", epoch)\n    \n        # Should have ACTIVATED and REWARDED events\n        assert len(coherence_ledger.ledger_entries) == 4\n        assert coherence_ledger.ledger_entries[2].entry_type == \"REFERRAL_ACTIVATED\"\n        assert coherence_ledger.ledger_entries[3].entry_type == \"REFERRAL_REWARDED\"\n    \n        reward_entry = coherence_ledger.ledger_entries[3]\n        event_data = reward_entry.data[\"event_data\"]\n        assert event_data[\"amount_scaled\"] == 10_000_000_000 # 100 FLX\n>       assert event_data[\"referrer_wallet\"] == referrer\nE       AssertionError: assert 'mock_referrer' == 'wallet_referrer_123'\nE         \nE         \u001b[0m\u001b[91m- wallet_referrer_123\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\nE         \u001b[92m+ mock_referrer\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\nv13\\tests\\unit\\test_referral_ledger_sync.py:45: AssertionError"}, "hash": "8db086ef4efe26d19ad63aff62dab8826075543dcc86f82e2a82885e5b141a446f9a7338fb5079e5b04ab587067a4a5dd892ab83a43bc76f9795e2d30469d9c6"}
{"timestamp": "2025-12-15T17:02:22.834186", "session_id": "5fa70496188e0d5a", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_referral_ledger_sync.py::test_referral_ledger_sync_flow", "context": {"env": "test"}, "details": {"duration": 0.0012002000003121793, "error": "def test_referral_ledger_sync_flow():\n        # Setup\n        with CertifiedMath.LogContext() as log_list:\n            cm = CertifiedMath()\n    \n        coherence_ledger = CoherenceLedger(cm)\n        referral_ledger = ReferralLedger(coherence_ledger)\n    \n        referrer = \"wallet_referrer_123\"\n        referee = \"wallet_referee_456\"\n        epoch = 101\n    \n        # 1. Create Link (Synchronous)\n        code = referral_ledger.create_link(referrer, epoch, \"test_source\")\n        assert code is not None\n        assert len(coherence_ledger.ledger_entries) == 1\n        assert coherence_ledger.ledger_entries[0].entry_type == \"REFERRAL_CREATED\"\n    \n        # 2. Accept\n        referral_ledger.accept(code, referee, epoch, \"device_hash_abc\")\n        assert len(coherence_ledger.ledger_entries) == 2\n        assert coherence_ledger.ledger_entries[1].entry_type == \"REFERRAL_ACCEPTED\"\n    \n        # 3. Activate & Grant Reward\n        # Mock _count_referrals to make sure we hit a tier (e.g. 0 -> 1st referral)\n        referral_ledger._count_referrals = lambda w: 0\n    \n        referral_ledger.activate(referee, \"PROFILE_COMPLETE\", epoch)\n    \n        # Should have ACTIVATED and REWARDED events\n        assert len(coherence_ledger.ledger_entries) == 4\n        assert coherence_ledger.ledger_entries[2].entry_type == \"REFERRAL_ACTIVATED\"\n        assert coherence_ledger.ledger_entries[3].entry_type == \"REFERRAL_REWARDED\"\n    \n        reward_entry = coherence_ledger.ledger_entries[3]\n        event_data = reward_entry.data[\"event_data\"]\n        assert event_data[\"amount_scaled\"] == 10_000_000_000 # 100 FLX\n>       assert event_data[\"referrer_wallet\"] == referrer\nE       AssertionError: assert 'mock_referrer' == 'wallet_referrer_123'\nE         \nE         - wallet_referrer_123\nE         + mock_referrer\n\nv13\\tests\\unit\\test_referral_ledger_sync.py:45: AssertionError"}, "hash": "eb9b1816e680081149d7c95cf87968d477f78dba7ddb7b9aee375fd420a04f74c233127925d483bd927514a1b7d8a7c8112e4d4fabd1c9a17869bc02974d06f2"}
{"timestamp": "2025-12-15T21:12:23.068676", "session_id": "c59ecba2f20b6669", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_phi_series.py::test_phi_series_basic_values", "context": {"env": "test"}, "details": {"duration": 0.00020650000078603625, "error": "def test_phi_series_basic_values():\n        \"\"\"Test phi_series function with basic values\"\"\"\n        with CertifiedMath.LogContext() as log:\n            # Test \u03c6(0) = 0\n            zero = BigNum128(0)\n>           result = CertifiedMath.safe_phi_series(zero, log)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           AttributeError: type object 'CertifiedMath' has no attribute 'safe_phi_series'\n\nv13\\tests\\unit\\test_phi_series.py:15: AttributeError"}, "hash": "bb180c682cab0eb30e83385b3364fc9e97c9b0a175db38844bdbed07ae302483905d644724b43ddcd2c01b7963895830691720f376b52b66c365f40e669e46ce"}
{"timestamp": "2025-12-15T21:12:23.079626", "session_id": "c59ecba2f20b6669", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_phi_series.py::test_phi_series_negative_values", "context": {"env": "test"}, "details": {"duration": 0.00018460000137565657, "error": "def test_phi_series_negative_values():\n        \"\"\"Test phi_series function with negative values\"\"\"\n        with CertifiedMath.LogContext() as log:\n            # Test \u03c6(-1)\n>           neg_one = BigNum128.from_int(-1)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n\nv13\\tests\\unit\\test_phi_series.py:30: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nv13\\libs\\BigNum128.py:42: in from_int\n    return cls(integer_val * cls.SCALE)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <[AttributeError(\"'BigNum128' object has no attribute 'value'\") raised in repr()] BigNum128 object at 0x198583e3bb0>, value = -1000000000000000000\n\n    def __init__(self, value: int):\n        if not isinstance(value, int):\n            raise TypeError(\"BigNum128 only accepts integers\")\n        if value < self.MIN_VALUE or value > self.MAX_VALUE:\n>           raise OverflowError(\n                f\"BigNum128 value {value} out of bounds [{self.MIN_VALUE}, {self.MAX_VALUE}]\"\n            )\nE           OverflowError: BigNum128 value -1000000000000000000 out of bounds [0, 340282366920938463463374607431768211455]\n\nv13\\libs\\BigNum128.py:34: OverflowError"}, "hash": "6727cb447847f1f3ca42e19399ab9e2dd740aa6b1744d295630d3002be15b258d5e3fedd3127bdd9cd2d2c776bc92653a7334947a5cfce896a26469f00727d0b"}
{"timestamp": "2025-12-15T21:12:23.084430", "session_id": "c59ecba2f20b6669", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_phi_series.py::test_phi_series_half_values", "context": {"env": "test"}, "details": {"duration": 0.00017830000433605164, "error": "def test_phi_series_half_values():\n        \"\"\"Test phi_series function with 0.5\"\"\"\n        with CertifiedMath.LogContext() as log:\n            # Test \u03c6(0.5)\n            half = BigNum128(500000000000000000)  # 0.5 * 1e18\n>           result = CertifiedMath.safe_phi_series(half, log, n=20)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           AttributeError: type object 'CertifiedMath' has no attribute 'safe_phi_series'\n\nv13\\tests\\unit\\test_phi_series.py:40: AttributeError"}, "hash": "511fbd80af573c885242d06211de1571a17f38f1b28ef33226a323c9c99a3d4f8e88222309c49aeaf6e99ab8c1e665b1334bcf0ce8053040a2c2e7a10eedbf77"}
{"timestamp": "2025-12-15T21:12:23.089063", "session_id": "c59ecba2f20b6669", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_phi_series.py::test_phi_series_deterministic", "context": {"env": "test"}, "details": {"duration": 0.00017659999866737053, "error": "def test_phi_series_deterministic():\n        \"\"\"Test that phi_series produces deterministic results\"\"\"\n        # Run the same calculation twice and ensure results are identical\n        with CertifiedMath.LogContext() as log1:\n            val = BigNum128.from_int(1)\n>           result1 = CertifiedMath.safe_phi_series(val, log1, n=15)\n                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           AttributeError: type object 'CertifiedMath' has no attribute 'safe_phi_series'\n\nv13\\tests\\unit\\test_phi_series.py:50: AttributeError"}, "hash": "e91ceca9c7f4bcbfac59659e8ca900c2c85ad2470e946252deeb9f5e12b0ad9d67d0b09613138f048ff5bca6315637fafb590f44b702f2be58968d0b22b12212"}
{"timestamp": "2025-12-15T21:12:23.094054", "session_id": "c59ecba2f20b6669", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_phi_series.py::test_phi_series_convergence", "context": {"env": "test"}, "details": {"duration": 0.00019699999393196777, "error": "def test_phi_series_convergence():\n        \"\"\"Test that increasing terms improves convergence\"\"\"\n        with CertifiedMath.LogContext() as log10:\n            val = BigNum128.from_int(1)\n>           result10 = CertifiedMath.safe_phi_series(val, log10, n=10)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           AttributeError: type object 'CertifiedMath' has no attribute 'safe_phi_series'\n\nv13\\tests\\unit\\test_phi_series.py:65: AttributeError"}, "hash": "ece0dd4689e1d498073c5843c86591257c0ae0ab27965181de7a98f7f34ccbe70a6a5c566e386881ebaa7e1bd2bf051c3f0821cadff1fada3284cdb0d29b2caf"}
{"timestamp": "2025-12-15T21:30:43.095837", "session_id": "e1a144d4441bce99", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_openagi_dm_integration.py::test_simulation_role_create_thread", "context": {"env": "test"}, "details": {"duration": 0.00036559999716700986, "error": "def test_simulation_role_create_thread():\n        \"\"\"OPEN-AGI simulation role creates a DM thread.\"\"\"\n        dm_service = DirectMessagingService()\n        adapter = OpenAGIDMAdapter(dm_service, scope=\"SIMULATION\")\n    \n        result = adapter.dm_create_thread(\"sim_user_1\", \"sim_user_2\")\n    \n>       assert \"thread_id\" in result\nE       AssertionError: assert 'thread_id' in {'error': 'RECIPIENT_NOT_FOUND'}\n\nv13\\tests\\unit\\test_openagi_dm_integration.py:18: AssertionError"}, "hash": "abceb3e3b61557432520b9afb28bdf10885f3e927104539e30aa7feff8a75da412852a0f6a75c94dc6b061ff1786995239217e046a97f7a6a3bad933887e2d3d"}
{"timestamp": "2025-12-15T21:30:43.204727", "session_id": "e1a144d4441bce99", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_openagi_dm_integration.py::test_dm_event_determinism", "context": {"env": "test"}, "details": {"duration": 0.00024879999546101317, "error": "def test_dm_event_determinism():\n        \"\"\"Same inputs produce same event structure.\"\"\"\n        dm_service = DirectMessagingService()\n        adapter = OpenAGIDMAdapter(dm_service, scope=\"SIMULATION\")\n    \n        result1 = adapter.dm_create_thread(\"user_a\", \"user_b\")\n        result2 = adapter.dm_create_thread(\"user_a\", \"user_b\")\n    \n        # Thread IDs should be deterministic\n>       assert result1[\"thread_id\"] == result2[\"thread_id\"]\n               ^^^^^^^^^^^^^^^^^^^^\nE       KeyError: 'thread_id'\n\nv13\\tests\\unit\\test_openagi_dm_integration.py:82: KeyError"}, "hash": "3f0ba83b5a45a2c65a294ad018fc94db8ea781ee44072448768000b05cdc3f2a17c7e5a5effbb7b07ce8f908b5e63eec7eea2d9170913df6e9c0532abf9e0188"}
{"timestamp": "2025-12-17T08:50:15.168283", "session_id": "dc36a023c4fd205d", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/test_audit_integrity.py::test_tamper_detection_chain", "context": {"env": "test"}, "details": {"duration": 0.00029689999064430594, "error": "def test_tamper_detection_chain():\n        \"\"\"Verify chain integrity checks.\"\"\"\n        prev_hash = \"abc12345\"\n    \n        # 1. Valid Record\n        record = {\n            \"prev_hash\": prev_hash,\n            \"action\": \"Legit Action\",\n            \"hash\": \"\" # Placeholder\n        }\n        # Calculate self hash excluding 'hash'\n        import json, hashlib\n        to_hash = {k: v for k, v in record.items() if k != \"hash\"}\n        json_str = json.dumps(to_hash, sort_keys=True, separators=(',', ':'))\n        record[\"hash\"] = hashlib.sha256(json_str.encode('utf-8')).hexdigest()\n    \n>       result = detect_tampering(record, prev_hash)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nv13\\tests\\test_audit_integrity.py:54: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nrecord = {'action': 'Legit Action', 'hash': 'd2eb7db6c6ef8b2493fb5b004c02bd65443276cab0942daedb2b01338fb02c03', 'prev_hash': 'abc12345'}\nprevious_hash = 'abc12345'\n\n    def detect_tampering(record: Dict[str, Any], previous_hash: str) -> Dict[str, Any]:\n        \"\"\"\n        Check a chain entry for tampering.\n    \n        Args:\n            record: The current audit log entry.\n            previous_hash: The hash of the previous entry in the chain.\n    \n        Returns:\n            Dict with 'valid' (bool) and 'error' (str, optional).\n        \"\"\"\n        # Verify strict chaining\n        if record.get(\"prev_hash\") != previous_hash:\n            return {\"valid\": False, \"error\": \"BROKEN_CHAIN_LINK\"}\n    \n        # Recalculate own hash\n        # Exclude 'hash' field from calculation\n            # Deterministic hashing of record fields (excluding hash itself)\n            # Sort items by key\n            sorted_items = sorted(record.items())\n            data_to_hash = {}\n            for i in range(len(sorted_items)):\n                k, v = sorted_items[i]\n                if k != \"hash\":\n                    data_to_hash[k] = v\n>       verified = verify_explanation_integrity(data_to_hash, record.get(\"hash\", \"\"))\n                                                ^^^^^^^^^^^^\nE       UnboundLocalError: cannot access local variable 'data_to_hash' where it is not associated with a value\n\nv13\\core\\audit_integrity.py:69: UnboundLocalError"}, "hash": "8e2f04fc48f6a61fb5fb52a0062f8e6b00074f85ca4ab17b134e1feb415bb127df3ed3e560b028bf367e45051009a447af1316b5ae0682fc7a3b58728cd43d41"}
{"timestamp": "2025-12-17T08:50:44.027908", "session_id": "c3a79579c5c3c65b", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/test_audit_integrity.py::test_tamper_detection_chain", "context": {"env": "test"}, "details": {"duration": 0.0003313999914098531, "error": "def test_tamper_detection_chain():\n        \"\"\"Verify chain integrity checks.\"\"\"\n        prev_hash = \"abc12345\"\n    \n        # 1. Valid Record\n        record = {\n            \"prev_hash\": prev_hash,\n            \"action\": \"Legit Action\",\n            \"hash\": \"\" # Placeholder\n        }\n        # Calculate self hash excluding 'hash'\n        import json, hashlib\n        to_hash = {k: v for k, v in record.items() if k != \"hash\"}\n        json_str = json.dumps(to_hash, sort_keys=True, separators=(',', ':'))\n        record[\"hash\"] = hashlib.sha256(json_str.encode('utf-8')).hexdigest()\n    \n>       result = detect_tampering(record, prev_hash)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nv13\\tests\\test_audit_integrity.py:54: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nrecord = {'action': 'Legit Action', 'hash': 'd2eb7db6c6ef8b2493fb5b004c02bd65443276cab0942daedb2b01338fb02c03', 'prev_hash': 'abc12345'}\nprevious_hash = 'abc12345'\n\n    def detect_tampering(record: Dict[str, Any], previous_hash: str) -> Dict[str, Any]:\n        \"\"\"\n        Check a chain entry for tampering.\n    \n        Args:\n            record: The current audit log entry.\n            previous_hash: The hash of the previous entry in the chain.\n    \n        Returns:\n            Dict with 'valid' (bool) and 'error' (str, optional).\n        \"\"\"\n        # Verify strict chaining\n        if record.get(\"prev_hash\") != previous_hash:\n            return {\"valid\": False, \"error\": \"BROKEN_CHAIN_LINK\"}\n    \n        # Recalculate own hash\n        # Exclude 'hash' field from calculation\n            # Deterministic hashing of record fields (excluding hash itself)\n            # Sort items by key\n            sorted_items = sorted(record.items())\n            data_to_hash = {}\n            for i in range(len(sorted_items)):\n                k, v = sorted_items[i]\n                if k != \"hash\":\n                    data_to_hash[k] = v\n>       verified = verify_explanation_integrity(data_to_hash, record.get(\"hash\", \"\"))\n                                                ^^^^^^^^^^^^\nE       UnboundLocalError: cannot access local variable 'data_to_hash' where it is not associated with a value\n\nv13\\core\\audit_integrity.py:69: UnboundLocalError"}, "hash": "704b5635869ae8e6b309ed6663b9c19aac08f085a59e5d0bcc02d3da09a00fe6d1abed75fc7d3a41beb7058dad500ef43b1be2d772fb1d10edee49af8b7b3963"}
