{"timestamp": "2025-12-15T16:27:01.345534", "session_id": "2ca08fd6a082ae9b", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_coherence_referral_integration.py::TestCoherenceReferralIntegration::test_referral_reward_application", "context": {"env": "test"}, "details": {"duration": 0.00025740000273799524, "error": "self = <v13.tests.unit.test_coherence_referral_integration.TestCoherenceReferralIntegration object at 0x000001976D983B10>\n\n    def test_referral_reward_application(self):\n        \"\"\"Test that CoherenceEngine correctly applies ReferralRewarded events to token state.\"\"\"\n        cm = CertifiedMath()\n        engine = CoherenceEngine(cm)\n    \n        # Initial State\n        referrer_wallet = \"0xReferrerWallet\"\n        initial_balance = \"100.0\"\n    \n        # Create initial bundle\n>       initial_bundle = create_token_state_bundle(\n            chr_state={},\n            flx_state={referrer_wallet: BigNum128.from_string(initial_balance)},\n            psi_sync_state={},\n            atr_state={},\n            res_state={},\n            nod_state={},\n            lambda1=BigNum128.from_int(1),\n            lambda2=BigNum128.from_int(1),\n            c_crit=BigNum128.from_int(1),\n            pqc_cid=\"test_cid\",\n            timestamp=1000\n        )\n\nv13\\tests\\unit\\test_coherence_referral_integration.py:20: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nv13\\core\\TokenStateBundle.py:463: in create_token_state_bundle\n    bundle_id = temp_bundle.get_deterministic_hash(include_signature=False)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = TokenStateBundle(chr_state={}, flx_state={'0xReferrerWallet': BigNum128(raw=100000000000000000000, fp='100.0')}, psi_s...=100000000000000000000000000, fp='100000000.0'), 'phi': BigNum128(raw=1618033988749894848, fp='1.618033988749894848')})\ninclude_signature = False\n\n    def get_deterministic_hash(self, include_signature: bool = True) -> str:\n        \"\"\"\n        Generate a deterministic SHA-256 hash of the TokenStateBundle.\n        This is used for bundle identification and integrity verification.\n    \n        Args:\n            include_signature: Whether to include the signature in the hash calculation\n    \n        Returns:\n            str: SHA-256 hash as hexadecimal string\n        \"\"\"\n>       serialized = json.dumps(self.to_dict(include_signature=include_signature), sort_keys=True, separators=(',', ':'))\n                     ^^^^\nE       NameError: name 'json' is not defined. Did you forget to import 'json'?\n\nv13\\core\\TokenStateBundle.py:381: NameError"}, "hash": "edd7d319d2c08bde4e1ee30c112bcd9d95c9bccca2315bea9aedbcc86e99f0997b835d1b19441e4971d538e9b88d60a629e4672e854440eed92140eb5841a9a7"}
{"timestamp": "2025-12-15T16:27:32.483309", "session_id": "ff13cb43b2234dda", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_coherence_referral_integration.py::TestCoherenceReferralIntegration::test_referral_reward_application", "context": {"env": "test"}, "details": {"duration": 0.00024019999909796752, "error": "self = <v13.tests.unit.test_coherence_referral_integration.TestCoherenceReferralIntegration object at 0x0000027F169BF890>\n\n    def test_referral_reward_application(self):\n        \"\"\"Test that CoherenceEngine correctly applies ReferralRewarded events to token state.\"\"\"\n        cm = CertifiedMath()\n        engine = CoherenceEngine(cm)\n    \n        # Initial State\n        referrer_wallet = \"0xReferrerWallet\"\n        initial_balance = \"100.0\"\n    \n        # Create initial bundle\n>       initial_bundle = create_token_state_bundle(\n            chr_state={},\n            flx_state={referrer_wallet: BigNum128.from_string(initial_balance)},\n            psi_sync_state={},\n            atr_state={},\n            res_state={},\n            nod_state={},\n            lambda1=BigNum128.from_int(1),\n            lambda2=BigNum128.from_int(1),\n            c_crit=BigNum128.from_int(1),\n            pqc_cid=\"test_cid\",\n            timestamp=1000\n        )\n\nv13\\tests\\unit\\test_coherence_referral_integration.py:20: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nv13\\core\\TokenStateBundle.py:463: in create_token_state_bundle\n    bundle_id = temp_bundle.get_deterministic_hash(include_signature=False)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = TokenStateBundle(chr_state={}, flx_state={'0xReferrerWallet': BigNum128(raw=100000000000000000000, fp='100.0')}, psi_s...=100000000000000000000000000, fp='100000000.0'), 'phi': BigNum128(raw=1618033988749894848, fp='1.618033988749894848')})\ninclude_signature = False\n\n    def get_deterministic_hash(self, include_signature: bool = True) -> str:\n        \"\"\"\n        Generate a deterministic SHA-256 hash of the TokenStateBundle.\n        This is used for bundle identification and integrity verification.\n    \n        Args:\n            include_signature: Whether to include the signature in the hash calculation\n    \n        Returns:\n            str: SHA-256 hash as hexadecimal string\n        \"\"\"\n>       serialized = json.dumps(self.to_dict(include_signature=include_signature), sort_keys=True, separators=(',', ':'))\n                     ^^^^\nE       NameError: name 'json' is not defined. Did you forget to import 'json'?\n\nv13\\core\\TokenStateBundle.py:381: NameError"}, "hash": "65bf6c2dbf638a8556501f192fb60d807a05a2327e29e1e5c0ba43129d33a3371b88b4b1c9266303dfdede76a1dfb4007b0839a1f936cc4adf3f219f8a143cce"}
{"timestamp": "2025-12-15T16:28:06.830187", "session_id": "b8d156f20207f4bd", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_coherence_referral_integration.py::TestCoherenceReferralIntegration::test_referral_reward_application", "context": {"env": "test"}, "details": {"duration": 0.0004907999973511323, "error": "self = <v13.tests.unit.test_coherence_referral_integration.TestCoherenceReferralIntegration object at 0x0000024993303890>\n\n    def test_referral_reward_application(self):\n        \"\"\"Test that CoherenceEngine correctly applies ReferralRewarded events to token state.\"\"\"\n        cm = CertifiedMath()\n        engine = CoherenceEngine(cm)\n    \n        # Initial State\n        referrer_wallet = \"0xReferrerWallet\"\n        initial_balance = \"100.0\"\n    \n        # Create initial bundle\n        initial_bundle = create_token_state_bundle(\n            chr_state={},\n            flx_state={referrer_wallet: BigNum128.from_string(initial_balance)},\n            psi_sync_state={},\n            atr_state={},\n            res_state={},\n            nod_state={},\n            lambda1=BigNum128.from_int(1),\n            lambda2=BigNum128.from_int(1),\n            c_crit=BigNum128.from_int(1),\n            pqc_cid=\"test_cid\",\n            timestamp=1000\n        )\n    \n        # Create ReferralRewarded event\n        reward_amount_scaled = 10_000_000_000 # 100 FLX (1e8 scale)\n        # Note: BigNum128 from_string(\"100.0\") is 100 * 1e18? Or 1e8?\n        # CertifiedMath/BigNum128 typically uses 1e18 or 1e9 depending on impl.\n        # The event uses 'amount_scaled' which usually implies integer units.\n        # But BigNum128.from_int(x) creates a BigNum with internal value x.\n        # If TokenState uses fixed point 1e18, we need to match.\n        # Let's assume the event amount is already in the correct \"atomic units\" for BigNum128.\n        # If BigNum128 expects 18 decimals, 100 FLX = 100 * 10^18.\n        # If ReferralLedger uses 10_000_000_000 (10^10), that might be small if 18 decimals.\n        # Let's check CertifiedMath/BigNum128 implementation if possibly, but in test we can assert the addition.\n    \n        event = ReferralRewarded(\n            referrer_wallet=referrer_wallet,\n            referee_wallet=\"0xReferee\",\n            token_type=\"FLX\",\n            amount_scaled=reward_amount_scaled,\n            epoch=101,\n            reason=\"Test Reward\",\n            guard_cir_code=\"PASS\"\n        )\n    \n        log_list = []\n    \n        # Apply transition\n        new_bundle = engine.apply_hsmf_transition(\n            current_bundle=initial_bundle,\n            log_list=log_list,\n            pqc_cid=\"test_cid_2\",\n            deterministic_timestamp=1100,\n            processed_events=[event]\n        )\n    \n        # Verify result\n        # Initial: 100.0 (BigNum128 likely parses decimal string to fixed point)\n        # Added: 10_000_000_000 (raw int)\n    \n        # We need to know what \"100.0\" becomes.\n        # If BigNum128 uses 1e18 scale: 100.0 -> 100 * 10^18 = 10^20.\n        # 10_000_000_000 is 10^10. So it is negligible.\n    \n        # HOWEVER, the ReferralLedger used 10_000_000_000 for \"100 FLX\" which implies 1e8 scale.\n        # If BigNum128 uses 1e18, then the Ledger is emitting wrong units OR BigNum128 handles it.\n        # For this test, effectively we just want to see Balance_New = Balance_Old + Reward.\n    \n        old_balance = initial_bundle.flx_state[referrer_wallet]\n        new_balance = new_bundle.flx_state[referrer_wallet]\n    \n        expected_balance = cm.add(old_balance, BigNum128.from_int(reward_amount_scaled), [])\n    \n        assert new_balance.value == expected_balance.value\n        assert new_balance.value > old_balance.value\n    \n        # Check logs\n        found_log = False\n>       for log in cm._audit_log: # Or check log_list if passed\n                   ^^^^^^^^^^^^^\nE       AttributeError: 'CertifiedMath' object has no attribute '_audit_log'\n\nv13\\tests\\unit\\test_coherence_referral_integration.py:89: AttributeError"}, "hash": "b3b2e84175d0f57c40f53848a02934f3ece2ac954b0d7a6ab33baebaf02bfaa6a13f454173a08fd1d6c18af7d1faf857d26e2695fd2c971f9d14838ad4221f60"}
{"timestamp": "2025-12-15T16:28:43.138661", "session_id": "acf666461d820285", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_coherence_referral_integration.py::TestCoherenceReferralIntegration::test_referral_reward_application", "context": {"env": "test"}, "details": {"duration": 0.0005178000028536189, "error": "self = <v13.tests.unit.test_coherence_referral_integration.TestCoherenceReferralIntegration object at 0x000002DB5873F610>\n\n    def test_referral_reward_application(self):\n        \"\"\"Test that CoherenceEngine correctly applies ReferralRewarded events to token state.\"\"\"\n        cm = CertifiedMath()\n        engine = CoherenceEngine(cm)\n    \n        # Initial State\n        referrer_wallet = \"0xReferrerWallet\"\n        initial_balance = \"100.0\"\n    \n        # Create initial bundle\n        initial_bundle = create_token_state_bundle(\n            chr_state={},\n            flx_state={referrer_wallet: BigNum128.from_string(initial_balance)},\n            psi_sync_state={},\n            atr_state={},\n            res_state={},\n            nod_state={},\n            lambda1=BigNum128.from_int(1),\n            lambda2=BigNum128.from_int(1),\n            c_crit=BigNum128.from_int(1),\n            pqc_cid=\"test_cid\",\n            timestamp=1000\n        )\n    \n        # Create ReferralRewarded event\n        reward_amount_scaled = 10_000_000_000 # 100 FLX (1e8 scale)\n        # Note: BigNum128 from_string(\"100.0\") is 100 * 1e18? Or 1e8?\n        # CertifiedMath/BigNum128 typically uses 1e18 or 1e9 depending on impl.\n        # The event uses 'amount_scaled' which usually implies integer units.\n        # But BigNum128.from_int(x) creates a BigNum with internal value x.\n        # If TokenState uses fixed point 1e18, we need to match.\n        # Let's assume the event amount is already in the correct \"atomic units\" for BigNum128.\n        # If BigNum128 expects 18 decimals, 100 FLX = 100 * 10^18.\n        # If ReferralLedger uses 10_000_000_000 (10^10), that might be small if 18 decimals.\n        # Let's check CertifiedMath/BigNum128 implementation if possibly, but in test we can assert the addition.\n    \n        event = ReferralRewarded(\n            referrer_wallet=referrer_wallet,\n            referee_wallet=\"0xReferee\",\n            token_type=\"FLX\",\n            amount_scaled=reward_amount_scaled,\n            epoch=101,\n            reason=\"Test Reward\",\n            guard_cir_code=\"PASS\"\n        )\n    \n        log_list = []\n    \n        # Apply transition\n        new_bundle = engine.apply_hsmf_transition(\n            current_bundle=initial_bundle,\n            log_list=log_list,\n            pqc_cid=\"test_cid_2\",\n            deterministic_timestamp=1100,\n            processed_events=[event]\n        )\n    \n        # Verify result\n        # Initial: 100.0 (BigNum128 likely parses decimal string to fixed point)\n        # Added: 10_000_000_000 (raw int)\n    \n        # We need to know what \"100.0\" becomes.\n        # If BigNum128 uses 1e18 scale: 100.0 -> 100 * 10^18 = 10^20.\n        # 10_000_000_000 is 10^10. So it is negligible.\n    \n        # HOWEVER, the ReferralLedger used 10_000_000_000 for \"100 FLX\" which implies 1e8 scale.\n        # If BigNum128 uses 1e18, then the Ledger is emitting wrong units OR BigNum128 handles it.\n        # For this test, effectively we just want to see Balance_New = Balance_Old + Reward.\n    \n        old_balance = initial_bundle.flx_state[referrer_wallet]\n        new_balance = new_bundle.flx_state[referrer_wallet]\n    \n        expected_balance = cm.add(old_balance, BigNum128.from_int(reward_amount_scaled), [])\n    \n        assert new_balance.value == expected_balance.value\n        assert new_balance.value > old_balance.value\n    \n        # Check logs\n        found_log = False\n        for log in log_list:\n             if log.get('operation') == 'apply_referral_reward':\n                 if log.get('input', {}).get('wallet') == referrer_wallet:\n                     found_log = True\n                     break\n    \n        # Verify that we found the log entry\n>       assert found_log, \"Referral reward application was not logged\"\nE       AssertionError: Referral reward application was not logged\nE       assert False\n\nv13\\tests\\unit\\test_coherence_referral_integration.py:96: AssertionError"}, "hash": "1ae430984d3621a973c196599be6bca61c804c6be085b7fdc7a021250941828167e86cf965e695f5b6bc4964f495fc6d100d94ff06948d5a00e9f3c4a137a260"}
{"timestamp": "2025-12-15T16:30:08.795673", "session_id": "e00392a364106388", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_coherence_referral_integration.py::TestCoherenceReferralIntegration::test_referral_reward_application", "context": {"env": "test"}, "details": {"duration": 0.000505299998621922, "error": "self = <v13.tests.unit.test_coherence_referral_integration.TestCoherenceReferralIntegration object at 0x0000019866DFF610>\n\n    def test_referral_reward_application(self):\n        \"\"\"Test that CoherenceEngine correctly applies ReferralRewarded events to token state.\"\"\"\n        cm = CertifiedMath()\n        engine = CoherenceEngine(cm)\n    \n        # Initial State\n        referrer_wallet = \"0xReferrerWallet\"\n        initial_balance = \"100.0\"\n    \n        # Create initial bundle\n        initial_bundle = create_token_state_bundle(\n            chr_state={},\n            flx_state={referrer_wallet: BigNum128.from_string(initial_balance)},\n            psi_sync_state={},\n            atr_state={},\n            res_state={},\n            nod_state={},\n            lambda1=BigNum128.from_int(1),\n            lambda2=BigNum128.from_int(1),\n            c_crit=BigNum128.from_int(1),\n            pqc_cid=\"test_cid\",\n            timestamp=1000\n        )\n    \n        # Create ReferralRewarded event\n        reward_amount_scaled = 10_000_000_000 # 100 FLX (1e8 scale)\n        # Note: BigNum128 from_string(\"100.0\") is 100 * 1e18? Or 1e8?\n        # CertifiedMath/BigNum128 typically uses 1e18 or 1e9 depending on impl.\n        # The event uses 'amount_scaled' which usually implies integer units.\n        # But BigNum128.from_int(x) creates a BigNum with internal value x.\n        # If TokenState uses fixed point 1e18, we need to match.\n        # Let's assume the event amount is already in the correct \"atomic units\" for BigNum128.\n        # If BigNum128 expects 18 decimals, 100 FLX = 100 * 10^18.\n        # If ReferralLedger uses 10_000_000_000 (10^10), that might be small if 18 decimals.\n        # Let's check CertifiedMath/BigNum128 implementation if possibly, but in test we can assert the addition.\n    \n        event = ReferralRewarded(\n            referrer_wallet=referrer_wallet,\n            referee_wallet=\"0xReferee\",\n            token_type=\"FLX\",\n            amount_scaled=reward_amount_scaled,\n            epoch=101,\n            reason=\"Test Reward\",\n            guard_cir_code=\"PASS\"\n        )\n    \n        log_list = []\n    \n        # Apply transition\n        new_bundle = engine.apply_hsmf_transition(\n            current_bundle=initial_bundle,\n            log_list=log_list,\n            pqc_cid=\"test_cid_2\",\n            deterministic_timestamp=1100,\n            processed_events=[event]\n        )\n    \n        # Verify result\n        # Initial: 100.0 (BigNum128 likely parses decimal string to fixed point)\n        # Added: 10_000_000_000 (raw int)\n    \n        # We need to know what \"100.0\" becomes.\n        # If BigNum128 uses 1e18 scale: 100.0 -> 100 * 10^18 = 10^20.\n        # 10_000_000_000 is 10^10. So it is negligible.\n    \n        # HOWEVER, the ReferralLedger used 10_000_000_000 for \"100 FLX\" which implies 1e8 scale.\n        # If BigNum128 uses 1e18, then the Ledger is emitting wrong units OR BigNum128 handles it.\n        # For this test, effectively we just want to see Balance_New = Balance_Old + Reward.\n    \n        old_balance = initial_bundle.flx_state[referrer_wallet]\n        new_balance = new_bundle.flx_state[referrer_wallet]\n    \n        expected_balance = cm.add(old_balance, BigNum128.from_int(reward_amount_scaled), [])\n    \n        assert new_balance.value == expected_balance.value\n        assert new_balance.value > old_balance.value\n    \n        # Check logs\n        found_log = False\n        for log in log_list:\n             if log.get('operation') == 'apply_referral_reward':\n                 if log.get('input', {}).get('wallet') == referrer_wallet:\n                     found_log = True\n                     break\n    \n        # Verify that we found the log entry\n>       assert found_log, \"Referral reward application was not logged\"\nE       AssertionError: Referral reward application was not logged\nE       assert False\n\nv13\\tests\\unit\\test_coherence_referral_integration.py:96: AssertionError"}, "hash": "621defe49327f15d4854e733e3e9cf090f657f2b72de2d2c1486a7795993bf8ce108b3d966334177243407fd6c6b3bae1beb4d0035fb201d527a94f78a7a0642"}
{"timestamp": "2025-12-15T16:30:43.193071", "session_id": "2ef501c60d73c9f9", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_coherence_referral_integration.py::TestCoherenceReferralIntegration::test_referral_reward_application", "context": {"env": "test"}, "details": {"duration": 0.0009042999990924727, "error": "self = <v13.tests.unit.test_coherence_referral_integration.TestCoherenceReferralIntegration object at 0x000001807829F610>\n\n    def test_referral_reward_application(self):\n        \"\"\"Test that CoherenceEngine correctly applies ReferralRewarded events to token state.\"\"\"\n        cm = CertifiedMath()\n        engine = CoherenceEngine(cm)\n    \n        # Initial State\n        referrer_wallet = \"0xReferrerWallet\"\n        initial_balance = \"100.0\"\n    \n        # Create initial bundle\n        initial_bundle = create_token_state_bundle(\n            chr_state={},\n            flx_state={referrer_wallet: BigNum128.from_string(initial_balance)},\n            psi_sync_state={},\n            atr_state={},\n            res_state={},\n            nod_state={},\n            lambda1=BigNum128.from_int(1),\n            lambda2=BigNum128.from_int(1),\n            c_crit=BigNum128.from_int(1),\n            pqc_cid=\"test_cid\",\n            timestamp=1000\n        )\n    \n        # Create ReferralRewarded event\n        reward_amount_scaled = 10_000_000_000 # 100 FLX (1e8 scale)\n        # Note: BigNum128 from_string(\"100.0\") is 100 * 1e18? Or 1e8?\n        # CertifiedMath/BigNum128 typically uses 1e18 or 1e9 depending on impl.\n        # The event uses 'amount_scaled' which usually implies integer units.\n        # But BigNum128.from_int(x) creates a BigNum with internal value x.\n        # If TokenState uses fixed point 1e18, we need to match.\n        # Let's assume the event amount is already in the correct \"atomic units\" for BigNum128.\n        # If BigNum128 expects 18 decimals, 100 FLX = 100 * 10^18.\n        # If ReferralLedger uses 10_000_000_000 (10^10), that might be small if 18 decimals.\n        # Let's check CertifiedMath/BigNum128 implementation if possibly, but in test we can assert the addition.\n    \n        event = ReferralRewarded(\n            referrer_wallet=referrer_wallet,\n            referee_wallet=\"0xReferee\",\n            token_type=\"FLX\",\n            amount_scaled=reward_amount_scaled,\n            epoch=101,\n            reason=\"Test Reward\",\n            guard_cir_code=\"PASS\"\n        )\n    \n        log_list = []\n    \n        # Apply transition\n        new_bundle = engine.apply_hsmf_transition(\n            current_bundle=initial_bundle,\n            log_list=log_list,\n            pqc_cid=\"test_cid_2\",\n            deterministic_timestamp=1100,\n            processed_events=[event]\n        )\n    \n        # Verify result\n        # Initial: 100.0 (BigNum128 likely parses decimal string to fixed point)\n        # Added: 10_000_000_000 (raw int)\n    \n        # We need to know what \"100.0\" becomes.\n        # If BigNum128 uses 1e18 scale: 100.0 -> 100 * 10^18 = 10^20.\n        # 10_000_000_000 is 10^10. So it is negligible.\n    \n        # HOWEVER, the ReferralLedger used 10_000_000_000 for \"100 FLX\" which implies 1e8 scale.\n        # If BigNum128 uses 1e18, then the Ledger is emitting wrong units OR BigNum128 handles it.\n        # For this test, effectively we just want to see Balance_New = Balance_Old + Reward.\n    \n        old_balance = initial_bundle.flx_state[referrer_wallet]\n        new_balance = new_bundle.flx_state[referrer_wallet]\n    \n        expected_balance = cm.add(old_balance, BigNum128.from_int(reward_amount_scaled), [])\n    \n        assert new_balance.value == expected_balance.value\n        assert new_balance.value > old_balance.value\n    \n        # Check logs\n        found_log = False\n        for log in log_list:\n             if log.get('operation') == 'apply_referral_reward':\n                 if log.get('input', {}).get('wallet') == referrer_wallet:\n                     found_log = True\n                     break\n    \n        # Verify that we found the log entry\n>       assert found_log, \"Referral reward application was not logged\"\nE       AssertionError: Referral reward application was not logged\nE       assert False\n\nv13\\tests\\unit\\test_coherence_referral_integration.py:96: AssertionError"}, "hash": "e4221501c1a9080cc15d183d7b292e3d46780e3fadf3e939ef94adc6ff6adb4c1f9b19540bc611a3ad4271367126db78962ed6e810c083f7a8ed3a5d42d30d91"}
{"timestamp": "2025-12-15T16:31:03.887555", "session_id": "511834d3e8061df4", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_coherence_referral_integration.py::TestCoherenceReferralIntegration::test_referral_reward_application", "context": {"env": "test"}, "details": {"duration": 0.0007608999985677656, "error": "self = <v13.tests.unit.test_coherence_referral_integration.TestCoherenceReferralIntegration object at 0x000002E54EB7EE90>\n\n    def test_referral_reward_application(self):\n        \"\"\"Test that CoherenceEngine correctly applies ReferralRewarded events to token state.\"\"\"\n        cm = CertifiedMath()\n        engine = CoherenceEngine(cm)\n    \n        # Initial State\n        referrer_wallet = \"0xReferrerWallet\"\n        initial_balance = \"100.0\"\n    \n        # Create initial bundle\n        initial_bundle = create_token_state_bundle(\n            chr_state={},\n            flx_state={referrer_wallet: BigNum128.from_string(initial_balance)},\n            psi_sync_state={},\n            atr_state={},\n            res_state={},\n            nod_state={},\n            lambda1=BigNum128.from_int(1),\n            lambda2=BigNum128.from_int(1),\n            c_crit=BigNum128.from_int(1),\n            pqc_cid=\"test_cid\",\n            timestamp=1000\n        )\n    \n        # Create ReferralRewarded event\n        reward_amount_scaled = 10_000_000_000 # 100 FLX (1e8 scale)\n        # Note: BigNum128 from_string(\"100.0\") is 100 * 1e18? Or 1e8?\n        # CertifiedMath/BigNum128 typically uses 1e18 or 1e9 depending on impl.\n        # The event uses 'amount_scaled' which usually implies integer units.\n        # But BigNum128.from_int(x) creates a BigNum with internal value x.\n        # If TokenState uses fixed point 1e18, we need to match.\n        # Let's assume the event amount is already in the correct \"atomic units\" for BigNum128.\n        # If BigNum128 expects 18 decimals, 100 FLX = 100 * 10^18.\n        # If ReferralLedger uses 10_000_000_000 (10^10), that might be small if 18 decimals.\n        # Let's check CertifiedMath/BigNum128 implementation if possibly, but in test we can assert the addition.\n    \n        event = ReferralRewarded(\n            referrer_wallet=referrer_wallet,\n            referee_wallet=\"0xReferee\",\n            token_type=\"FLX\",\n            amount_scaled=reward_amount_scaled,\n            epoch=101,\n            reason=\"Test Reward\",\n            guard_cir_code=\"PASS\"\n        )\n    \n        log_list = []\n    \n        # Apply transition\n        new_bundle = engine.apply_hsmf_transition(\n            current_bundle=initial_bundle,\n            log_list=log_list,\n            pqc_cid=\"test_cid_2\",\n            deterministic_timestamp=1100,\n            processed_events=[event]\n        )\n    \n        # Verify result\n        # Initial: 100.0 (BigNum128 likely parses decimal string to fixed point)\n        # Added: 10_000_000_000 (raw int)\n    \n        # We need to know what \"100.0\" becomes.\n        # If BigNum128 uses 1e18 scale: 100.0 -> 100 * 10^18 = 10^20.\n        # 10_000_000_000 is 10^10. So it is negligible.\n    \n        # HOWEVER, the ReferralLedger used 10_000_000_000 for \"100 FLX\" which implies 1e8 scale.\n        # If BigNum128 uses 1e18, then the Ledger is emitting wrong units OR BigNum128 handles it.\n        # For this test, effectively we just want to see Balance_New = Balance_Old + Reward.\n    \n        old_balance = initial_bundle.flx_state[referrer_wallet]\n        new_balance = new_bundle.flx_state[referrer_wallet]\n    \n        expected_balance = cm.add(old_balance, BigNum128.from_int(reward_amount_scaled), [])\n    \n        assert new_balance.value == expected_balance.value\n        assert new_balance.value > old_balance.value\n    \n        # Check logs\n        found_log = False\n        for log in log_list:\n             if log.get('operation') == 'apply_referral_reward':\n                 if log.get('input', {}).get('wallet') == referrer_wallet:\n                     found_log = True\n                     break\n    \n        # Verify that we found the log entry\n>       assert found_log, \"Referral reward application was not logged\"\nE       AssertionError: Referral reward application was not logged\nE       assert False\n\nv13\\tests\\unit\\test_coherence_referral_integration.py:96: AssertionError"}, "hash": "373064e82c38d4d7754927dfd020a8a7444b87f0c8c67f3168d11458ba096cb24df7b17de9c0e708a5a6adc7572b1b5f8ed9e0e39d296652b0e9c33854e93cb1"}
{"timestamp": "2025-12-15T16:31:44.059721", "session_id": "be3f45186196f35c", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_coherence_referral_integration.py::TestCoherenceReferralIntegration::test_referral_reward_application", "context": {"env": "test"}, "details": {"duration": 0.0009006000000226777, "error": "self = <v13.tests.unit.test_coherence_referral_integration.TestCoherenceReferralIntegration object at 0x00000274C5362E90>\n\n    def test_referral_reward_application(self):\n        \"\"\"Test that CoherenceEngine correctly applies ReferralRewarded events to token state.\"\"\"\n        cm = CertifiedMath()\n        engine = CoherenceEngine(cm)\n    \n        # Initial State\n        referrer_wallet = \"0xReferrerWallet\"\n        initial_balance = \"100.0\"\n    \n        # Create initial bundle\n        initial_bundle = create_token_state_bundle(\n            chr_state={},\n            flx_state={referrer_wallet: BigNum128.from_string(initial_balance)},\n            psi_sync_state={},\n            atr_state={},\n            res_state={},\n            nod_state={},\n            lambda1=BigNum128.from_int(1),\n            lambda2=BigNum128.from_int(1),\n            c_crit=BigNum128.from_int(1),\n            pqc_cid=\"test_cid\",\n            timestamp=1000\n        )\n    \n        # Create ReferralRewarded event\n        reward_amount_scaled = 10_000_000_000 # 100 FLX (1e8 scale)\n        # Note: BigNum128 from_string(\"100.0\") is 100 * 1e18? Or 1e8?\n        # CertifiedMath/BigNum128 typically uses 1e18 or 1e9 depending on impl.\n        # The event uses 'amount_scaled' which usually implies integer units.\n        # But BigNum128.from_int(x) creates a BigNum with internal value x.\n        # If TokenState uses fixed point 1e18, we need to match.\n        # Let's assume the event amount is already in the correct \"atomic units\" for BigNum128.\n        # If BigNum128 expects 18 decimals, 100 FLX = 100 * 10^18.\n        # If ReferralLedger uses 10_000_000_000 (10^10), that might be small if 18 decimals.\n        # Let's check CertifiedMath/BigNum128 implementation if possibly, but in test we can assert the addition.\n    \n        event = ReferralRewarded(\n            referrer_wallet=referrer_wallet,\n            referee_wallet=\"0xReferee\",\n            token_type=\"FLX\",\n            amount_scaled=reward_amount_scaled,\n            epoch=101,\n            reason=\"Test Reward\",\n            guard_cir_code=\"PASS\"\n        )\n    \n        log_list = []\n    \n        # Apply transition\n        new_bundle = engine.apply_hsmf_transition(\n            current_bundle=initial_bundle,\n            log_list=log_list,\n            pqc_cid=\"test_cid_2\",\n            deterministic_timestamp=1100,\n            processed_events=[event]\n        )\n    \n        # Verify result\n        # Initial: 100.0 (BigNum128 likely parses decimal string to fixed point)\n        # Added: 10_000_000_000 (raw int)\n    \n        # We need to know what \"100.0\" becomes.\n        # If BigNum128 uses 1e18 scale: 100.0 -> 100 * 10^18 = 10^20.\n        # 10_000_000_000 is 10^10. So it is negligible.\n    \n        # HOWEVER, the ReferralLedger used 10_000_000_000 for \"100 FLX\" which implies 1e8 scale.\n        # If BigNum128 uses 1e18, then the Ledger is emitting wrong units OR BigNum128 handles it.\n        # For this test, effectively we just want to see Balance_New = Balance_Old + Reward.\n    \n        old_balance = initial_bundle.flx_state[referrer_wallet]\n        new_balance = new_bundle.flx_state[referrer_wallet]\n    \n        expected_balance = cm.add(old_balance, BigNum128.from_int(reward_amount_scaled), [])\n    \n        assert new_balance.value == expected_balance.value\n        assert new_balance.value > old_balance.value\n    \n        # Check logs\n        found_log = False\n        for log in log_list:\n             if log.get('operation') == 'apply_referral_reward':\n                 if log.get('input', {}).get('wallet') == referrer_wallet:\n                     found_log = True\n                     break\n    \n        # Verify that we found the log entry\n>       assert found_log, \"Referral reward application was not logged\"\nE       AssertionError: Referral reward application was not logged\nE       assert False\n\nv13\\tests\\unit\\test_coherence_referral_integration.py:96: AssertionError"}, "hash": "43fe6c5578bfc7642608d3275a23fb61fe5c3a74f24d47cfea86d7d5922cdb8427c1c02d53a277f45b389a1536ef290be75bab60ad4ab8f18f704e2cb6e783c1"}
{"timestamp": "2025-12-15T16:32:23.415084", "session_id": "aefa306be4d8daf2", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_coherence_referral_integration.py::TestCoherenceReferralIntegration::test_referral_reward_application", "context": {"env": "test"}, "details": {"duration": 0.0015225000024656765, "error": "self = <v13.tests.unit.test_coherence_referral_integration.TestCoherenceReferralIntegration object at 0x0000020E5689F610>\n\n    def test_referral_reward_application(self):\n        \"\"\"Test that CoherenceEngine correctly applies ReferralRewarded events to token state.\"\"\"\n        cm = CertifiedMath()\n        engine = CoherenceEngine(cm)\n    \n        # Initial State\n        referrer_wallet = \"0xReferrerWallet\"\n        initial_balance = \"100.0\"\n    \n        # Create initial bundle\n        initial_bundle = create_token_state_bundle(\n            chr_state={},\n            flx_state={referrer_wallet: BigNum128.from_string(initial_balance)},\n            psi_sync_state={},\n            atr_state={},\n            res_state={},\n            nod_state={},\n            lambda1=BigNum128.from_int(1),\n            lambda2=BigNum128.from_int(1),\n            c_crit=BigNum128.from_int(1),\n            pqc_cid=\"test_cid\",\n            timestamp=1000\n        )\n    \n        # Create ReferralRewarded event\n        reward_amount_scaled = 10_000_000_000 # 100 FLX (1e8 scale)\n        # Note: BigNum128 from_string(\"100.0\") is 100 * 1e18? Or 1e8?\n        # CertifiedMath/BigNum128 typically uses 1e18 or 1e9 depending on impl.\n        # The event uses 'amount_scaled' which usually implies integer units.\n        # But BigNum128.from_int(x) creates a BigNum with internal value x.\n        # If TokenState uses fixed point 1e18, we need to match.\n        # Let's assume the event amount is already in the correct \"atomic units\" for BigNum128.\n        # If BigNum128 expects 18 decimals, 100 FLX = 100 * 10^18.\n        # If ReferralLedger uses 10_000_000_000 (10^10), that might be small if 18 decimals.\n        # Let's check CertifiedMath/BigNum128 implementation if possibly, but in test we can assert the addition.\n    \n        event = ReferralRewarded(\n            referrer_wallet=referrer_wallet,\n            referee_wallet=\"0xReferee\",\n            token_type=\"FLX\",\n            amount_scaled=reward_amount_scaled,\n            epoch=101,\n            reason=\"Test Reward\",\n            guard_cir_code=\"PASS\"\n        )\n    \n        log_list = []\n    \n        # Apply transition\n        new_bundle = engine.apply_hsmf_transition(\n            current_bundle=initial_bundle,\n            log_list=log_list,\n            pqc_cid=\"test_cid_2\",\n            deterministic_timestamp=1100,\n            processed_events=[event]\n        )\n    \n        # Verify result\n        # Initial: 100.0 (BigNum128 likely parses decimal string to fixed point)\n        # Added: 10_000_000_000 (raw int)\n    \n        # We need to know what \"100.0\" becomes.\n        # If BigNum128 uses 1e18 scale: 100.0 -> 100 * 10^18 = 10^20.\n        # 10_000_000_000 is 10^10. So it is negligible.\n    \n        # HOWEVER, the ReferralLedger used 10_000_000_000 for \"100 FLX\" which implies 1e8 scale.\n        # If BigNum128 uses 1e18, then the Ledger is emitting wrong units OR BigNum128 handles it.\n        # For this test, effectively we just want to see Balance_New = Balance_Old + Reward.\n    \n        old_balance = initial_bundle.flx_state[referrer_wallet]\n        new_balance = new_bundle.flx_state[referrer_wallet]\n    \n        expected_balance = cm.add(old_balance, BigNum128.from_int(reward_amount_scaled), [])\n    \n        assert new_balance.value == expected_balance.value\n        assert new_balance.value > old_balance.value\n    \n        # Check logs\n        found_log = False\n        for log in log_list:\n             if log.get('operation') == 'apply_referral_reward':\n                 if log.get('input', {}).get('wallet') == referrer_wallet:\n                     found_log = True\n                     break\n    \n        # Verify that we found the log entry\n>       assert found_log, \"Referral reward application was not logged\"\nE       AssertionError: Referral reward application was not logged\nE       assert False\n\nv13\\tests\\unit\\test_coherence_referral_integration.py:96: AssertionError"}, "hash": "3c3b8903ab48c83075b1ed068e77bab68eb59670841295da0ac3ddd32aef8a76411dc354fabc150fb9702bdaf549223060b5edde36d6232489d12f43ba49d29e"}
{"timestamp": "2025-12-15T16:34:27.128126", "session_id": "178bae76e58b427a", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/test_ast_zerosimchecker_modules.py::test_golden_files", "context": {"env": "test"}, "details": {"duration": 0.0014646999989054166, "error": "def test_golden_files():\n        \"\"\"Test the static golden files for Zero-Sim compliance.\"\"\"\n        checker = AST_ZeroSimChecker()\n        current_dir = os.path.dirname(os.path.abspath(__file__))\n    \n        pass_file = os.path.join(current_dir, \"unit\", \"zero_sim_golden_pass.py\")\n        if not os.path.exists(pass_file):\n             # Try expecting it in the same directory as this test\n             pass_file = os.path.join(current_dir, \"zero_sim_golden_pass.py\")\n             if not os.path.exists(pass_file):\n                 # Fallback to v13/tests/unit\n                 pass_file = os.path.join(current_dir, \"..\", \"unit\", \"zero_sim_golden_pass.py\")\n    \n        # Ensure file exists before testing\n        assert os.path.exists(pass_file), f\"Golden pass file not found at {pass_file}\"\n    \n        violations = checker.scan_file(pass_file)\n        assert len(violations) == 0, f\"Golden pass file has violations: {violations}\"\n    \n        fail_file = os.path.join(current_dir, \"unit\", \"zero_sim_golden_fail.py\")\n        if not os.path.exists(fail_file):\n             fail_file = os.path.join(current_dir, \"zero_sim_golden_fail.py\")\n             if not os.path.exists(fail_file):\n                 fail_file = os.path.join(current_dir, \"..\", \"unit\", \"zero_sim_golden_fail.py\")\n    \n        assert os.path.exists(fail_file), f\"Golden fail file not found at {fail_file}\"\n    \n        violations = checker.scan_file(fail_file)\n        assert len(violations) > 0, \"Golden fail file has no violations\"\n    \n        # Check for specific violations we expect\n        import_violations = [v for v in violations if v.violation_type == \"FORBIDDEN_IMPORT\"]\n        call_violations = [v for v in violations if v.violation_type == \"FORBIDDEN_CALL\"]\n    \n        assert len(import_violations) > 0, \"Golden fail file missing FORBIDDEN_IMPORT violation\"\n>       assert len(call_violations) > 0, \"Golden fail file missing FORBIDDEN_CALL violation\"\nE       AssertionError: Golden fail file missing FORBIDDEN_CALL violation\nE       assert 0 > 0\nE        +  where 0 = len([])\n\nv13\\tests\\test_ast_zerosimchecker_modules.py:182: AssertionError"}, "hash": "1f9ad35c89d51da9e401e8a6487aac9f693471a717318f445d827dd821e73ff365b240fca1adcab95c25a99276f57fb39e713237a309676057798e4caaecb83f"}
{"timestamp": "2025-12-15T16:35:01.911410", "session_id": "241564f7413d3c1c", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/test_ast_zerosimchecker_modules.py::test_golden_files", "context": {"env": "test"}, "details": {"duration": 0.0013873000025341753, "error": "def test_golden_files():\n        \"\"\"Test the static golden files for Zero-Sim compliance.\"\"\"\n        checker = AST_ZeroSimChecker()\n        current_dir = os.path.dirname(os.path.abspath(__file__))\n    \n        pass_file = os.path.join(current_dir, \"unit\", \"zero_sim_golden_pass.py\")\n        if not os.path.exists(pass_file):\n             # Try expecting it in the same directory as this test\n             pass_file = os.path.join(current_dir, \"zero_sim_golden_pass.py\")\n             if not os.path.exists(pass_file):\n                 # Fallback to v13/tests/unit\n                 pass_file = os.path.join(current_dir, \"..\", \"unit\", \"zero_sim_golden_pass.py\")\n    \n        # Ensure file exists before testing\n        assert os.path.exists(pass_file), f\"Golden pass file not found at {pass_file}\"\n    \n        violations = checker.scan_file(pass_file)\n        assert len(violations) == 0, f\"Golden pass file has violations: {violations}\"\n    \n        fail_file = os.path.join(current_dir, \"unit\", \"zero_sim_golden_fail.py\")\n        if not os.path.exists(fail_file):\n             fail_file = os.path.join(current_dir, \"zero_sim_golden_fail.py\")\n             if not os.path.exists(fail_file):\n                 fail_file = os.path.join(current_dir, \"..\", \"unit\", \"zero_sim_golden_fail.py\")\n    \n        assert os.path.exists(fail_file), f\"Golden fail file not found at {fail_file}\"\n    \n        violations = checker.scan_file(fail_file)\n        assert len(violations) > 0, \"Golden fail file has no violations\"\n    \n        # Check for specific violations we expect\n        import_violations = [v for v in violations if v.violation_type == \"FORBIDDEN_IMPORT\"]\n        call_violations = [v for v in violations if v.violation_type == \"FORBIDDEN_CALL\"]\n    \n        assert len(import_violations) > 0, \"Golden fail file missing FORBIDDEN_IMPORT violation\"\n>       assert len(call_violations) > 0, \"Golden fail file missing FORBIDDEN_CALL violation\"\nE       AssertionError: Golden fail file missing FORBIDDEN_CALL violation\nE       assert 0 > 0\nE        +  where 0 = len([])\n\nv13\\tests\\test_ast_zerosimchecker_modules.py:182: AssertionError"}, "hash": "0493d1a0a9b4768c03548548bbfed0b95e9af91589a77b5560200fdce325d2a833d656233c4785ebe928f4bf2cd6d984ba5347c4a9bbffafb786397314a701dd"}
{"timestamp": "2025-12-15T16:36:17.459824", "session_id": "b38b8e521654a4fd", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/test_ast_zerosimchecker_modules.py::test_golden_files", "context": {"env": "test"}, "details": {"duration": 0.001438600000255974, "error": "def test_golden_files():\n        \"\"\"Test the static golden files for Zero-Sim compliance.\"\"\"\n        checker = AST_ZeroSimChecker()\n        current_dir = os.path.dirname(os.path.abspath(__file__))\n        # Assuming test is in v13/tests/ and compliance is in v13/compliance/\n        # Go up one level from tests/ to v13/\n        project_root = os.path.dirname(current_dir)\n    \n        pass_file = os.path.join(project_root, \"compliance\", \"golden_pass.py\")\n    \n        # Ensure file exists before testing\n        assert os.path.exists(pass_file), f\"Golden pass file not found at {pass_file}\"\n    \n        violations = checker.scan_file(pass_file)\n        assert len(violations) == 0, f\"Golden pass file has violations: {violations}\"\n    \n        fail_file = os.path.join(project_root, \"compliance\", \"golden_fail.py\")\n    \n        assert os.path.exists(fail_file), f\"Golden fail file not found at {fail_file}\"\n    \n        violations = checker.scan_file(fail_file)\n        assert len(violations) > 0, \"Golden fail file has no violations (check if it was excluded?)\"\n    \n        # Check for specific violations we expect\n        import_violations = [v for v in violations if v.violation_type == \"FORBIDDEN_IMPORT\"]\n        call_violations = [v for v in violations if v.violation_type == \"FORBIDDEN_CALL\"]\n    \n        assert len(import_violations) > 0, \"Golden fail file missing FORBIDDEN_IMPORT violation\"\n>       assert len(call_violations) > 0, \"Golden fail file missing FORBIDDEN_CALL violation\"\nE       AssertionError: Golden fail file missing FORBIDDEN_CALL violation\nE       assert 0 > 0\nE        +  where 0 = len([])\n\nv13\\tests\\test_ast_zerosimchecker_modules.py:175: AssertionError"}, "hash": "7166accc6f11a238868d51ed3585a5e6f0993259be3a9ce457b480ee4b6e236bb5d4f527dc73d9f9bdf4d7c8cbc14b1ca5f87e5dc0e0fadd26f11b47db8a04a5"}
{"timestamp": "2025-12-15T16:37:00.894866", "session_id": "3271182855e5e8c0", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/test_ast_zerosimchecker_modules.py::test_golden_files", "context": {"env": "test"}, "details": {"duration": 0.0016199000019696541, "error": "def test_golden_files():\n        \"\"\"Test the static golden files for Zero-Sim compliance.\"\"\"\n        checker = AST_ZeroSimChecker()\n        current_dir = os.path.dirname(os.path.abspath(__file__))\n        # Assuming test is in v13/tests/ and compliance is in v13/compliance/\n        # Go up one level from tests/ to v13/\n        project_root = os.path.dirname(current_dir)\n    \n        pass_file = os.path.join(project_root, \"compliance\", \"golden_pass.py\")\n    \n        # Ensure file exists before testing\n        assert os.path.exists(pass_file), f\"Golden pass file not found at {pass_file}\"\n    \n        violations = checker.scan_file(pass_file)\n        assert len(violations) == 0, f\"Golden pass file has violations: {violations}\"\n    \n        fail_file = os.path.join(project_root, \"compliance\", \"golden_fail.py\")\n    \n        assert os.path.exists(fail_file), f\"Golden fail file not found at {fail_file}\"\n    \n        violations = checker.scan_file(fail_file)\n        print(f\"DEBUG: Scanned {fail_file}\")\n        print(f\"DEBUG: Found {len(violations)} violations: {violations}\")\n        assert len(violations) > 0, f\"Golden fail file has no violations (check if it was excluded?). Violations: {violations}\"\n    \n        # Check for specific violations we expect\n        import_violations = [v for v in violations if v.violation_type == \"FORBIDDEN_IMPORT\"]\n        call_violations = [v for v in violations if v.violation_type == \"FORBIDDEN_CALL\"]\n    \n        assert len(import_violations) > 0, \"Golden fail file missing FORBIDDEN_IMPORT violation\"\n>       assert len(call_violations) > 0, \"Golden fail file missing FORBIDDEN_CALL violation\"\nE       AssertionError: Golden fail file missing FORBIDDEN_CALL violation\nE       assert 0 > 0\nE        +  where 0 = len([])\n\nv13\\tests\\test_ast_zerosimchecker_modules.py:177: AssertionError"}, "hash": "1bfc36d7a4a3c4a328e2e57f433f4de3efe9fd9dbd3e4f23832062343542177ca271b1f2361f6b986d4278427d4a340ef41680dff6070a321c8f564198b35a2c"}
{"timestamp": "2025-12-15T16:37:45.530766", "session_id": "b6bf5684ac5f3967", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/test_ast_zerosimchecker_modules.py::test_golden_files", "context": {"env": "test"}, "details": {"duration": 0.0019815999985439703, "error": "def test_golden_files():\n        \"\"\"Test the static golden files for Zero-Sim compliance.\"\"\"\n        checker = AST_ZeroSimChecker()\n        current_dir = os.path.dirname(os.path.abspath(__file__))\n        # Assuming test is in v13/tests/ and compliance is in v13/compliance/\n        # Go up one level from tests/ to v13/\n        project_root = os.path.dirname(current_dir)\n    \n        pass_file = os.path.join(project_root, \"compliance\", \"golden_pass.py\")\n    \n        # Ensure file exists before testing\n        assert os.path.exists(pass_file), f\"Golden pass file not found at {pass_file}\"\n    \n        violations = checker.scan_file(pass_file)\n        assert len(violations) == 0, f\"Golden pass file has violations: {violations}\"\n    \n        fail_file = os.path.join(project_root, \"compliance\", \"golden_fail.py\")\n    \n        assert os.path.exists(fail_file), f\"Golden fail file not found at {fail_file}\"\n    \n        violations = checker.scan_file(fail_file)\n        with open(\"debug_test_log.txt\", \"w\") as f:\n            f.write(f\"DEBUG: Scanned {fail_file}\\n\")\n            f.write(f\"DEBUG: Found {len(violations)} violations\\n\")\n            for v in violations:\n                 f.write(f\" Violation: {v}\\n\")\n    \n        assert len(violations) > 0, f\"Golden fail file has no violations (check if it was excluded?). Violations: {violations}\"\n    \n        # Check for specific violations we expect\n        import_violations = [v for v in violations if v.violation_type == \"FORBIDDEN_IMPORT\"]\n        call_violations = [v for v in violations if v.violation_type == \"FORBIDDEN_CALL\"]\n    \n        assert len(import_violations) > 0, \"Golden fail file missing FORBIDDEN_IMPORT violation\"\n>       assert len(call_violations) > 0, \"Golden fail file missing FORBIDDEN_CALL violation\"\nE       AssertionError: Golden fail file missing FORBIDDEN_CALL violation\nE       assert 0 > 0\nE        +  where 0 = len([])\n\nv13\\tests\\test_ast_zerosimchecker_modules.py:181: AssertionError"}, "hash": "c12a54ef0d4a015e42c36310b4ded58ec7c965f6b616fa33a093744bba346c737862fccee7b58a1dacafc0c23d1222cdd15804cf937c1c706d62d62798ae9a8d"}
{"timestamp": "2025-12-15T16:58:51.263573", "session_id": "f9ecea376fe83453", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_referral_ledger_sync.py::test_referral_ledger_sync_flow", "context": {"env": "test"}, "details": {"duration": 0.004231200000504032, "error": "def test_referral_ledger_sync_flow():\n        # Setup\n        with CertifiedMath.LogContext() as log_list:\n            cm = CertifiedMath()\n    \n        coherence_ledger = CoherenceLedger(cm)\n        referral_ledger = ReferralLedger(coherence_ledger)\n    \n        referrer = \"wallet_referrer_123\"\n        referee = \"wallet_referee_456\"\n        epoch = 101\n    \n        # 1. Create Link (Synchronous)\n        code = referral_ledger.create_link(referrer, epoch, \"test_source\")\n        assert code is not None\n        assert len(coherence_ledger.ledger_entries) == 1\n        assert coherence_ledger.ledger_entries[0].entry_type == \"REFERRAL_CREATED\"\n    \n        # 2. Accept\n        referral_ledger.accept(code, referee, epoch, \"device_hash_abc\")\n        assert len(coherence_ledger.ledger_entries) == 2\n        assert coherence_ledger.ledger_entries[1].entry_type == \"REFERRAL_ACCEPTED\"\n    \n        # 3. Activate & Grant Reward\n        # Mock _count_referrals to make sure we hit a tier (e.g. 0 -> 1st referral)\n        referral_ledger._count_referrals = lambda w: 0\n    \n        referral_ledger.activate(referee, \"PROFILE_COMPLETE\", epoch)\n    \n        # Should have ACTIVATED and REWARDED events\n        assert len(coherence_ledger.ledger_entries) == 4\n        assert coherence_ledger.ledger_entries[2].entry_type == \"REFERRAL_ACTIVATED\"\n        assert coherence_ledger.ledger_entries[3].entry_type == \"REFERRAL_REWARDED\"\n    \n        reward_entry = coherence_ledger.ledger_entries[3]\n        event_data = reward_entry.data[\"event_data\"]\n        assert event_data[\"amount_scaled\"] == 10_000_000_000 # 100 FLX\n>       assert event_data[\"referrer_wallet\"] == referrer\nE       AssertionError: assert 'mock_referrer' == 'wallet_referrer_123'\nE         \nE         \u001b[0m\u001b[91m- wallet_referrer_123\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\nE         \u001b[92m+ mock_referrer\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\nv13\\tests\\unit\\test_referral_ledger_sync.py:45: AssertionError"}, "hash": "20d3f197f654b5e584d452d73f52713a91bba418d9464413b00b6aca223ff325f54efd5119b60671adb4219c9a56c2511b72dbad9e2f58573a7353410ff0a7dc"}
{"timestamp": "2025-12-15T16:59:15.000366", "session_id": "4a3210341daf2cf9", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_referral_ledger_sync.py::test_referral_ledger_sync_flow", "context": {"env": "test"}, "details": {"duration": 0.0011421999988669995, "error": "def test_referral_ledger_sync_flow():\n        # Setup\n        with CertifiedMath.LogContext() as log_list:\n            cm = CertifiedMath()\n    \n        coherence_ledger = CoherenceLedger(cm)\n        referral_ledger = ReferralLedger(coherence_ledger)\n    \n        referrer = \"wallet_referrer_123\"\n        referee = \"wallet_referee_456\"\n        epoch = 101\n    \n        # 1. Create Link (Synchronous)\n        code = referral_ledger.create_link(referrer, epoch, \"test_source\")\n        assert code is not None\n        assert len(coherence_ledger.ledger_entries) == 1\n        assert coherence_ledger.ledger_entries[0].entry_type == \"REFERRAL_CREATED\"\n    \n        # 2. Accept\n        referral_ledger.accept(code, referee, epoch, \"device_hash_abc\")\n        assert len(coherence_ledger.ledger_entries) == 2\n        assert coherence_ledger.ledger_entries[1].entry_type == \"REFERRAL_ACCEPTED\"\n    \n        # 3. Activate & Grant Reward\n        # Mock _count_referrals to make sure we hit a tier (e.g. 0 -> 1st referral)\n        referral_ledger._count_referrals = lambda w: 0\n    \n        referral_ledger.activate(referee, \"PROFILE_COMPLETE\", epoch)\n    \n        # Should have ACTIVATED and REWARDED events\n        assert len(coherence_ledger.ledger_entries) == 4\n        assert coherence_ledger.ledger_entries[2].entry_type == \"REFERRAL_ACTIVATED\"\n        assert coherence_ledger.ledger_entries[3].entry_type == \"REFERRAL_REWARDED\"\n    \n        reward_entry = coherence_ledger.ledger_entries[3]\n        event_data = reward_entry.data[\"event_data\"]\n        assert event_data[\"amount_scaled\"] == 10_000_000_000 # 100 FLX\n>       assert event_data[\"referrer_wallet\"] == referrer\nE       AssertionError: assert 'mock_referrer' == 'wallet_referrer_123'\nE         \nE         \u001b[0m\u001b[91m- wallet_referrer_123\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\nE         \u001b[92m+ mock_referrer\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\nv13\\tests\\unit\\test_referral_ledger_sync.py:45: AssertionError"}, "hash": "8db086ef4efe26d19ad63aff62dab8826075543dcc86f82e2a82885e5b141a446f9a7338fb5079e5b04ab587067a4a5dd892ab83a43bc76f9795e2d30469d9c6"}
{"timestamp": "2025-12-15T17:02:22.834186", "session_id": "5fa70496188e0d5a", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_referral_ledger_sync.py::test_referral_ledger_sync_flow", "context": {"env": "test"}, "details": {"duration": 0.0012002000003121793, "error": "def test_referral_ledger_sync_flow():\n        # Setup\n        with CertifiedMath.LogContext() as log_list:\n            cm = CertifiedMath()\n    \n        coherence_ledger = CoherenceLedger(cm)\n        referral_ledger = ReferralLedger(coherence_ledger)\n    \n        referrer = \"wallet_referrer_123\"\n        referee = \"wallet_referee_456\"\n        epoch = 101\n    \n        # 1. Create Link (Synchronous)\n        code = referral_ledger.create_link(referrer, epoch, \"test_source\")\n        assert code is not None\n        assert len(coherence_ledger.ledger_entries) == 1\n        assert coherence_ledger.ledger_entries[0].entry_type == \"REFERRAL_CREATED\"\n    \n        # 2. Accept\n        referral_ledger.accept(code, referee, epoch, \"device_hash_abc\")\n        assert len(coherence_ledger.ledger_entries) == 2\n        assert coherence_ledger.ledger_entries[1].entry_type == \"REFERRAL_ACCEPTED\"\n    \n        # 3. Activate & Grant Reward\n        # Mock _count_referrals to make sure we hit a tier (e.g. 0 -> 1st referral)\n        referral_ledger._count_referrals = lambda w: 0\n    \n        referral_ledger.activate(referee, \"PROFILE_COMPLETE\", epoch)\n    \n        # Should have ACTIVATED and REWARDED events\n        assert len(coherence_ledger.ledger_entries) == 4\n        assert coherence_ledger.ledger_entries[2].entry_type == \"REFERRAL_ACTIVATED\"\n        assert coherence_ledger.ledger_entries[3].entry_type == \"REFERRAL_REWARDED\"\n    \n        reward_entry = coherence_ledger.ledger_entries[3]\n        event_data = reward_entry.data[\"event_data\"]\n        assert event_data[\"amount_scaled\"] == 10_000_000_000 # 100 FLX\n>       assert event_data[\"referrer_wallet\"] == referrer\nE       AssertionError: assert 'mock_referrer' == 'wallet_referrer_123'\nE         \nE         - wallet_referrer_123\nE         + mock_referrer\n\nv13\\tests\\unit\\test_referral_ledger_sync.py:45: AssertionError"}, "hash": "eb9b1816e680081149d7c95cf87968d477f78dba7ddb7b9aee375fd420a04f74c233127925d483bd927514a1b7d8a7c8112e4d4fabd1c9a17869bc02974d06f2"}
{"timestamp": "2025-12-15T21:12:23.068676", "session_id": "c59ecba2f20b6669", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_phi_series.py::test_phi_series_basic_values", "context": {"env": "test"}, "details": {"duration": 0.00020650000078603625, "error": "def test_phi_series_basic_values():\n        \"\"\"Test phi_series function with basic values\"\"\"\n        with CertifiedMath.LogContext() as log:\n            # Test \u03c6(0) = 0\n            zero = BigNum128(0)\n>           result = CertifiedMath.safe_phi_series(zero, log)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           AttributeError: type object 'CertifiedMath' has no attribute 'safe_phi_series'\n\nv13\\tests\\unit\\test_phi_series.py:15: AttributeError"}, "hash": "bb180c682cab0eb30e83385b3364fc9e97c9b0a175db38844bdbed07ae302483905d644724b43ddcd2c01b7963895830691720f376b52b66c365f40e669e46ce"}
{"timestamp": "2025-12-15T21:12:23.079626", "session_id": "c59ecba2f20b6669", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_phi_series.py::test_phi_series_negative_values", "context": {"env": "test"}, "details": {"duration": 0.00018460000137565657, "error": "def test_phi_series_negative_values():\n        \"\"\"Test phi_series function with negative values\"\"\"\n        with CertifiedMath.LogContext() as log:\n            # Test \u03c6(-1)\n>           neg_one = BigNum128.from_int(-1)\n                      ^^^^^^^^^^^^^^^^^^^^^^\n\nv13\\tests\\unit\\test_phi_series.py:30: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nv13\\libs\\BigNum128.py:42: in from_int\n    return cls(integer_val * cls.SCALE)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <[AttributeError(\"'BigNum128' object has no attribute 'value'\") raised in repr()] BigNum128 object at 0x198583e3bb0>, value = -1000000000000000000\n\n    def __init__(self, value: int):\n        if not isinstance(value, int):\n            raise TypeError(\"BigNum128 only accepts integers\")\n        if value < self.MIN_VALUE or value > self.MAX_VALUE:\n>           raise OverflowError(\n                f\"BigNum128 value {value} out of bounds [{self.MIN_VALUE}, {self.MAX_VALUE}]\"\n            )\nE           OverflowError: BigNum128 value -1000000000000000000 out of bounds [0, 340282366920938463463374607431768211455]\n\nv13\\libs\\BigNum128.py:34: OverflowError"}, "hash": "6727cb447847f1f3ca42e19399ab9e2dd740aa6b1744d295630d3002be15b258d5e3fedd3127bdd9cd2d2c776bc92653a7334947a5cfce896a26469f00727d0b"}
{"timestamp": "2025-12-15T21:12:23.084430", "session_id": "c59ecba2f20b6669", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_phi_series.py::test_phi_series_half_values", "context": {"env": "test"}, "details": {"duration": 0.00017830000433605164, "error": "def test_phi_series_half_values():\n        \"\"\"Test phi_series function with 0.5\"\"\"\n        with CertifiedMath.LogContext() as log:\n            # Test \u03c6(0.5)\n            half = BigNum128(500000000000000000)  # 0.5 * 1e18\n>           result = CertifiedMath.safe_phi_series(half, log, n=20)\n                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           AttributeError: type object 'CertifiedMath' has no attribute 'safe_phi_series'\n\nv13\\tests\\unit\\test_phi_series.py:40: AttributeError"}, "hash": "511fbd80af573c885242d06211de1571a17f38f1b28ef33226a323c9c99a3d4f8e88222309c49aeaf6e99ab8c1e665b1334bcf0ce8053040a2c2e7a10eedbf77"}
{"timestamp": "2025-12-15T21:12:23.089063", "session_id": "c59ecba2f20b6669", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_phi_series.py::test_phi_series_deterministic", "context": {"env": "test"}, "details": {"duration": 0.00017659999866737053, "error": "def test_phi_series_deterministic():\n        \"\"\"Test that phi_series produces deterministic results\"\"\"\n        # Run the same calculation twice and ensure results are identical\n        with CertifiedMath.LogContext() as log1:\n            val = BigNum128.from_int(1)\n>           result1 = CertifiedMath.safe_phi_series(val, log1, n=15)\n                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           AttributeError: type object 'CertifiedMath' has no attribute 'safe_phi_series'\n\nv13\\tests\\unit\\test_phi_series.py:50: AttributeError"}, "hash": "e91ceca9c7f4bcbfac59659e8ca900c2c85ad2470e946252deeb9f5e12b0ad9d67d0b09613138f048ff5bca6315637fafb590f44b702f2be58968d0b22b12212"}
{"timestamp": "2025-12-15T21:12:23.094054", "session_id": "c59ecba2f20b6669", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_phi_series.py::test_phi_series_convergence", "context": {"env": "test"}, "details": {"duration": 0.00019699999393196777, "error": "def test_phi_series_convergence():\n        \"\"\"Test that increasing terms improves convergence\"\"\"\n        with CertifiedMath.LogContext() as log10:\n            val = BigNum128.from_int(1)\n>           result10 = CertifiedMath.safe_phi_series(val, log10, n=10)\n                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           AttributeError: type object 'CertifiedMath' has no attribute 'safe_phi_series'\n\nv13\\tests\\unit\\test_phi_series.py:65: AttributeError"}, "hash": "ece0dd4689e1d498073c5843c86591257c0ae0ab27965181de7a98f7f34ccbe70a6a5c566e386881ebaa7e1bd2bf051c3f0821cadff1fada3284cdb0d29b2caf"}
{"timestamp": "2025-12-15T21:30:43.095837", "session_id": "e1a144d4441bce99", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_openagi_dm_integration.py::test_simulation_role_create_thread", "context": {"env": "test"}, "details": {"duration": 0.00036559999716700986, "error": "def test_simulation_role_create_thread():\n        \"\"\"OPEN-AGI simulation role creates a DM thread.\"\"\"\n        dm_service = DirectMessagingService()\n        adapter = OpenAGIDMAdapter(dm_service, scope=\"SIMULATION\")\n    \n        result = adapter.dm_create_thread(\"sim_user_1\", \"sim_user_2\")\n    \n>       assert \"thread_id\" in result\nE       AssertionError: assert 'thread_id' in {'error': 'RECIPIENT_NOT_FOUND'}\n\nv13\\tests\\unit\\test_openagi_dm_integration.py:18: AssertionError"}, "hash": "abceb3e3b61557432520b9afb28bdf10885f3e927104539e30aa7feff8a75da412852a0f6a75c94dc6b061ff1786995239217e046a97f7a6a3bad933887e2d3d"}
{"timestamp": "2025-12-15T21:30:43.204727", "session_id": "e1a144d4441bce99", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_openagi_dm_integration.py::test_dm_event_determinism", "context": {"env": "test"}, "details": {"duration": 0.00024879999546101317, "error": "def test_dm_event_determinism():\n        \"\"\"Same inputs produce same event structure.\"\"\"\n        dm_service = DirectMessagingService()\n        adapter = OpenAGIDMAdapter(dm_service, scope=\"SIMULATION\")\n    \n        result1 = adapter.dm_create_thread(\"user_a\", \"user_b\")\n        result2 = adapter.dm_create_thread(\"user_a\", \"user_b\")\n    \n        # Thread IDs should be deterministic\n>       assert result1[\"thread_id\"] == result2[\"thread_id\"]\n               ^^^^^^^^^^^^^^^^^^^^\nE       KeyError: 'thread_id'\n\nv13\\tests\\unit\\test_openagi_dm_integration.py:82: KeyError"}, "hash": "3f0ba83b5a45a2c65a294ad018fc94db8ea781ee44072448768000b05cdc3f2a17c7e5a5effbb7b07ce8f908b5e63eec7eea2d9170913df6e9c0532abf9e0188"}
{"timestamp": "2025-12-17T08:50:15.168283", "session_id": "dc36a023c4fd205d", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/test_audit_integrity.py::test_tamper_detection_chain", "context": {"env": "test"}, "details": {"duration": 0.00029689999064430594, "error": "def test_tamper_detection_chain():\n        \"\"\"Verify chain integrity checks.\"\"\"\n        prev_hash = \"abc12345\"\n    \n        # 1. Valid Record\n        record = {\n            \"prev_hash\": prev_hash,\n            \"action\": \"Legit Action\",\n            \"hash\": \"\" # Placeholder\n        }\n        # Calculate self hash excluding 'hash'\n        import json, hashlib\n        to_hash = {k: v for k, v in record.items() if k != \"hash\"}\n        json_str = json.dumps(to_hash, sort_keys=True, separators=(',', ':'))\n        record[\"hash\"] = hashlib.sha256(json_str.encode('utf-8')).hexdigest()\n    \n>       result = detect_tampering(record, prev_hash)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nv13\\tests\\test_audit_integrity.py:54: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nrecord = {'action': 'Legit Action', 'hash': 'd2eb7db6c6ef8b2493fb5b004c02bd65443276cab0942daedb2b01338fb02c03', 'prev_hash': 'abc12345'}\nprevious_hash = 'abc12345'\n\n    def detect_tampering(record: Dict[str, Any], previous_hash: str) -> Dict[str, Any]:\n        \"\"\"\n        Check a chain entry for tampering.\n    \n        Args:\n            record: The current audit log entry.\n            previous_hash: The hash of the previous entry in the chain.\n    \n        Returns:\n            Dict with 'valid' (bool) and 'error' (str, optional).\n        \"\"\"\n        # Verify strict chaining\n        if record.get(\"prev_hash\") != previous_hash:\n            return {\"valid\": False, \"error\": \"BROKEN_CHAIN_LINK\"}\n    \n        # Recalculate own hash\n        # Exclude 'hash' field from calculation\n            # Deterministic hashing of record fields (excluding hash itself)\n            # Sort items by key\n            sorted_items = sorted(record.items())\n            data_to_hash = {}\n            for i in range(len(sorted_items)):\n                k, v = sorted_items[i]\n                if k != \"hash\":\n                    data_to_hash[k] = v\n>       verified = verify_explanation_integrity(data_to_hash, record.get(\"hash\", \"\"))\n                                                ^^^^^^^^^^^^\nE       UnboundLocalError: cannot access local variable 'data_to_hash' where it is not associated with a value\n\nv13\\core\\audit_integrity.py:69: UnboundLocalError"}, "hash": "8e2f04fc48f6a61fb5fb52a0062f8e6b00074f85ca4ab17b134e1feb415bb127df3ed3e560b028bf367e45051009a447af1316b5ae0682fc7a3b58728cd43d41"}
{"timestamp": "2025-12-17T08:50:44.027908", "session_id": "c3a79579c5c3c65b", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/test_audit_integrity.py::test_tamper_detection_chain", "context": {"env": "test"}, "details": {"duration": 0.0003313999914098531, "error": "def test_tamper_detection_chain():\n        \"\"\"Verify chain integrity checks.\"\"\"\n        prev_hash = \"abc12345\"\n    \n        # 1. Valid Record\n        record = {\n            \"prev_hash\": prev_hash,\n            \"action\": \"Legit Action\",\n            \"hash\": \"\" # Placeholder\n        }\n        # Calculate self hash excluding 'hash'\n        import json, hashlib\n        to_hash = {k: v for k, v in record.items() if k != \"hash\"}\n        json_str = json.dumps(to_hash, sort_keys=True, separators=(',', ':'))\n        record[\"hash\"] = hashlib.sha256(json_str.encode('utf-8')).hexdigest()\n    \n>       result = detect_tampering(record, prev_hash)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nv13\\tests\\test_audit_integrity.py:54: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nrecord = {'action': 'Legit Action', 'hash': 'd2eb7db6c6ef8b2493fb5b004c02bd65443276cab0942daedb2b01338fb02c03', 'prev_hash': 'abc12345'}\nprevious_hash = 'abc12345'\n\n    def detect_tampering(record: Dict[str, Any], previous_hash: str) -> Dict[str, Any]:\n        \"\"\"\n        Check a chain entry for tampering.\n    \n        Args:\n            record: The current audit log entry.\n            previous_hash: The hash of the previous entry in the chain.\n    \n        Returns:\n            Dict with 'valid' (bool) and 'error' (str, optional).\n        \"\"\"\n        # Verify strict chaining\n        if record.get(\"prev_hash\") != previous_hash:\n            return {\"valid\": False, \"error\": \"BROKEN_CHAIN_LINK\"}\n    \n        # Recalculate own hash\n        # Exclude 'hash' field from calculation\n            # Deterministic hashing of record fields (excluding hash itself)\n            # Sort items by key\n            sorted_items = sorted(record.items())\n            data_to_hash = {}\n            for i in range(len(sorted_items)):\n                k, v = sorted_items[i]\n                if k != \"hash\":\n                    data_to_hash[k] = v\n>       verified = verify_explanation_integrity(data_to_hash, record.get(\"hash\", \"\"))\n                                                ^^^^^^^^^^^^\nE       UnboundLocalError: cannot access local variable 'data_to_hash' where it is not associated with a value\n\nv13\\core\\audit_integrity.py:69: UnboundLocalError"}, "hash": "704b5635869ae8e6b309ed6663b9c19aac08f085a59e5d0bcc02d3da09a00fe6d1abed75fc7d3a41beb7058dad500ef43b1be2d772fb1d10edee49af8b7b3963"}
{"timestamp": "2025-12-17T09:45:31.587612", "session_id": "a280672b2fade2a3", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/governance/test_appeals_deterministic.py::test_scoring_determinism", "context": {"env": "test"}, "details": {"duration": 0.00037360002170316875, "error": "def test_scoring_determinism():\n        \"\"\"Same votes + same evidence must yield same score.\"\"\"\n        evidence = {\"id\": \"ev_001\", \"content\": \"spam\"}\n        votes = [\n            Vote(voter_id=\"alice\", reputation=1000, approve=True),  # +1000\n            Vote(voter_id=\"bob\", reputation=500, approve=False),  # -500\n        ]\n    \n        # Net = 500. Threshold = 400. -> Approved.\n>       res1 = score_appeal(evidence, votes, threshold=400)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nv13\\tests\\governance\\test_appeals_deterministic.py:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nevidence_payload = {'content': 'spam', 'id': 'ev_001'}\nvotes = [Vote(voter_id='alice', reputation=1000, approve=True, weight=100), Vote(voter_id='bob', reputation=500, approve=False, weight=100)], threshold = 400\n\n    def score_appeal(\n        evidence_payload: Dict[str, Any],\n        votes: List[Vote],\n        threshold: int = 5000,  # 50.00 ATR\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Calculate the final score for an appeal.\n    \n        Args:\n            evidence_payload: The raw evidence dictionary.\n            votes: List of cast votes.\n            threshold: Score required for approval (Scale 100).\n    \n        Returns:\n            Dict with 'approved' (bool), 'score' (int), 'hash' (str).\n        \"\"\"\n        # 1. Canonical Hash (The 'Seed')\n        ev_hash = hash_evidence(evidence_payload)\n    \n        # 2. Calculate Tally using CertifiedMath\n        # We use basic integer math here as CertifiedMath wrappers are mainly for\n        # complex funcs (log, exp) or safe division. For additions, standard int matches\n        # Zero-Sim if inputs are integers.\n    \n        score_approve = 0\n        score_reject = 0\n    \n        for v in votes:\n            # Weight = VoteWeight * (Reputation / 100)\n            # Scale: weight(100) * rep(1000) / 100 = 1000.\n            # Use CertifiedMath for division to be safe and consistent.\n    \n            # effective_weight = (v.weight * v.reputation) // 100\n>           effective_weight = CertifiedMath.idiv(v.weight * v.reputation, 100)\n                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           TypeError: CertifiedMath.idiv() missing 1 required positional argument: 'b_int'\n\nv13\\services\\governance\\appeals.py:63: TypeError"}, "hash": "f71bb50338226e17ea57fb1a05b3781e404a842086ef10b74c4fd07123a20d7496a875f711af1298f1dbf273853344769e155526c7a12a28677399513a9a55f1"}
{"timestamp": "2025-12-17T09:45:31.616938", "session_id": "a280672b2fade2a3", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/governance/test_appeals_deterministic.py::test_scoring_threshold_failure", "context": {"env": "test"}, "details": {"duration": 0.00033870001789182425, "error": "def test_scoring_threshold_failure():\n        \"\"\"Net score below threshold -> Rejected.\"\"\"\n        evidence = {\"id\": \"ev_002\"}\n        votes = [\n            Vote(voter_id=\"alice\", reputation=200, approve=True)  # +200\n        ]\n    \n>       res = score_appeal(evidence, votes, threshold=500)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nv13\\tests\\governance\\test_appeals_deterministic.py:36: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nevidence_payload = {'id': 'ev_002'}, votes = [Vote(voter_id='alice', reputation=200, approve=True, weight=100)], threshold = 500\n\n    def score_appeal(\n        evidence_payload: Dict[str, Any],\n        votes: List[Vote],\n        threshold: int = 5000,  # 50.00 ATR\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Calculate the final score for an appeal.\n    \n        Args:\n            evidence_payload: The raw evidence dictionary.\n            votes: List of cast votes.\n            threshold: Score required for approval (Scale 100).\n    \n        Returns:\n            Dict with 'approved' (bool), 'score' (int), 'hash' (str).\n        \"\"\"\n        # 1. Canonical Hash (The 'Seed')\n        ev_hash = hash_evidence(evidence_payload)\n    \n        # 2. Calculate Tally using CertifiedMath\n        # We use basic integer math here as CertifiedMath wrappers are mainly for\n        # complex funcs (log, exp) or safe division. For additions, standard int matches\n        # Zero-Sim if inputs are integers.\n    \n        score_approve = 0\n        score_reject = 0\n    \n        for v in votes:\n            # Weight = VoteWeight * (Reputation / 100)\n            # Scale: weight(100) * rep(1000) / 100 = 1000.\n            # Use CertifiedMath for division to be safe and consistent.\n    \n            # effective_weight = (v.weight * v.reputation) // 100\n>           effective_weight = CertifiedMath.idiv(v.weight * v.reputation, 100)\n                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           TypeError: CertifiedMath.idiv() missing 1 required positional argument: 'b_int'\n\nv13\\services\\governance\\appeals.py:63: TypeError"}, "hash": "70bffdafe147a0490fef7d021879ac07f7bceaa7ff0139ad2b0c98d2fd2abecdd88e315cbbd8e73290a000ea645f8027037c37c3576b5833b40535326e91c51d"}
{"timestamp": "2025-12-17T09:45:31.683443", "session_id": "a280672b2fade2a3", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/governance/test_appeals_deterministic.py::test_rounding_safety", "context": {"env": "test"}, "details": {"duration": 0.0003039000148419291, "error": "def test_rounding_safety():\n        \"\"\"Verify integer division behavior via CertifiedMath.\"\"\"\n        # Weight 100 * Rep 55 // 100 = 55\n        votes = [Vote(voter_id=\"v\", reputation=55, approve=True)]\n>       res = score_appeal({}, votes, threshold=0)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nv13\\tests\\governance\\test_appeals_deterministic.py:45: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nevidence_payload = {}, votes = [Vote(voter_id='v', reputation=55, approve=True, weight=100)], threshold = 0\n\n    def score_appeal(\n        evidence_payload: Dict[str, Any],\n        votes: List[Vote],\n        threshold: int = 5000,  # 50.00 ATR\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Calculate the final score for an appeal.\n    \n        Args:\n            evidence_payload: The raw evidence dictionary.\n            votes: List of cast votes.\n            threshold: Score required for approval (Scale 100).\n    \n        Returns:\n            Dict with 'approved' (bool), 'score' (int), 'hash' (str).\n        \"\"\"\n        # 1. Canonical Hash (The 'Seed')\n        ev_hash = hash_evidence(evidence_payload)\n    \n        # 2. Calculate Tally using CertifiedMath\n        # We use basic integer math here as CertifiedMath wrappers are mainly for\n        # complex funcs (log, exp) or safe division. For additions, standard int matches\n        # Zero-Sim if inputs are integers.\n    \n        score_approve = 0\n        score_reject = 0\n    \n        for v in votes:\n            # Weight = VoteWeight * (Reputation / 100)\n            # Scale: weight(100) * rep(1000) / 100 = 1000.\n            # Use CertifiedMath for division to be safe and consistent.\n    \n            # effective_weight = (v.weight * v.reputation) // 100\n>           effective_weight = CertifiedMath.idiv(v.weight * v.reputation, 100)\n                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           TypeError: CertifiedMath.idiv() missing 1 required positional argument: 'b_int'\n\nv13\\services\\governance\\appeals.py:63: TypeError"}, "hash": "b2d0467644e27e13d5fb3817639c5939e3706752cf30669b2b4489c820d2fe439ca616fe606337aa24d13a8d0a69a529de3739db51172e800b5b9ec9c9a7e074"}
{"timestamp": "2025-12-17T09:45:54.131718", "session_id": "dc5b1602591e8c18", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/governance/test_appeals_deterministic.py::test_scoring_determinism", "context": {"env": "test"}, "details": {"duration": 0.000282000022707507, "error": "def test_scoring_determinism():\n        \"\"\"Same votes + same evidence must yield same score.\"\"\"\n        evidence = {\"id\": \"ev_001\", \"content\": \"spam\"}\n        votes = [\n            Vote(voter_id=\"alice\", reputation=1000, approve=True),  # +1000\n            Vote(voter_id=\"bob\", reputation=500, approve=False),  # -500\n        ]\n    \n        # Net = 500. Threshold = 400. -> Approved.\n>       res1 = score_appeal(evidence, votes, threshold=400)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nv13\\tests\\governance\\test_appeals_deterministic.py:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nevidence_payload = {'content': 'spam', 'id': 'ev_001'}\nvotes = [Vote(voter_id='alice', reputation=1000, approve=True, weight=100), Vote(voter_id='bob', reputation=500, approve=False, weight=100)], threshold = 400\n\n    def score_appeal(\n        evidence_payload: Dict[str, Any],\n        votes: List[Vote],\n        threshold: int = 5000,  # 50.00 ATR\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Calculate the final score for an appeal.\n    \n        Args:\n            evidence_payload: The raw evidence dictionary.\n            votes: List of cast votes.\n            threshold: Score required for approval (Scale 100).\n    \n        Returns:\n            Dict with 'approved' (bool), 'score' (int), 'hash' (str).\n        \"\"\"\n        # 1. Canonical Hash (The 'Seed')\n        ev_hash = hash_evidence(evidence_payload)\n    \n        # 2. Calculate Tally using CertifiedMath\n        # We use basic integer math here as CertifiedMath wrappers are mainly for\n        # complex funcs (log, exp) or safe division. For additions, standard int matches\n        # Zero-Sim if inputs are integers.\n    \n        score_approve = 0\n        score_reject = 0\n    \n        for v in votes:\n            # Weight = VoteWeight * (Reputation / 100)\n            # Scale: weight(100) * rep(1000) / 100 = 1000.\n            # Use CertifiedMath for division to be safe and consistent.\n    \n            # effective_weight = (v.weight * v.reputation) // 100\n>           effective_weight = CertifiedMath.idiv(v.weight * v.reputation, 100)\n                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           TypeError: CertifiedMath.idiv() missing 1 required positional argument: 'b_int'\n\nv13\\services\\governance\\appeals.py:63: TypeError"}, "hash": "bfebb7e27658bc70637815c733df04f755389740b60e695a0a8eaa85d319f2a1a9ce750f9aff83406f8e775638a97658e1ac771fce265737275416bec842477c"}
{"timestamp": "2025-12-17T09:45:54.140551", "session_id": "dc5b1602591e8c18", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/governance/test_appeals_deterministic.py::test_scoring_threshold_failure", "context": {"env": "test"}, "details": {"duration": 0.00025770001229830086, "error": "def test_scoring_threshold_failure():\n        \"\"\"Net score below threshold -> Rejected.\"\"\"\n        evidence = {\"id\": \"ev_002\"}\n        votes = [\n            Vote(voter_id=\"alice\", reputation=200, approve=True)  # +200\n        ]\n    \n>       res = score_appeal(evidence, votes, threshold=500)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nv13\\tests\\governance\\test_appeals_deterministic.py:36: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nevidence_payload = {'id': 'ev_002'}, votes = [Vote(voter_id='alice', reputation=200, approve=True, weight=100)], threshold = 500\n\n    def score_appeal(\n        evidence_payload: Dict[str, Any],\n        votes: List[Vote],\n        threshold: int = 5000,  # 50.00 ATR\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Calculate the final score for an appeal.\n    \n        Args:\n            evidence_payload: The raw evidence dictionary.\n            votes: List of cast votes.\n            threshold: Score required for approval (Scale 100).\n    \n        Returns:\n            Dict with 'approved' (bool), 'score' (int), 'hash' (str).\n        \"\"\"\n        # 1. Canonical Hash (The 'Seed')\n        ev_hash = hash_evidence(evidence_payload)\n    \n        # 2. Calculate Tally using CertifiedMath\n        # We use basic integer math here as CertifiedMath wrappers are mainly for\n        # complex funcs (log, exp) or safe division. For additions, standard int matches\n        # Zero-Sim if inputs are integers.\n    \n        score_approve = 0\n        score_reject = 0\n    \n        for v in votes:\n            # Weight = VoteWeight * (Reputation / 100)\n            # Scale: weight(100) * rep(1000) / 100 = 1000.\n            # Use CertifiedMath for division to be safe and consistent.\n    \n            # effective_weight = (v.weight * v.reputation) // 100\n>           effective_weight = CertifiedMath.idiv(v.weight * v.reputation, 100)\n                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           TypeError: CertifiedMath.idiv() missing 1 required positional argument: 'b_int'\n\nv13\\services\\governance\\appeals.py:63: TypeError"}, "hash": "75005db28e126d384a9e0a3eba8e6beab959402094011c82a075e78ffe560c6bad22593c8e85feb887f4bf52db77373b4ad9cf39455ce7c2847714a200a097c5"}
{"timestamp": "2025-12-17T09:45:54.148415", "session_id": "dc5b1602591e8c18", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/governance/test_appeals_deterministic.py::test_rounding_safety", "context": {"env": "test"}, "details": {"duration": 0.00023029997828416526, "error": "def test_rounding_safety():\n        \"\"\"Verify integer division behavior via CertifiedMath.\"\"\"\n        # Weight 100 * Rep 55 // 100 = 55\n        votes = [Vote(voter_id=\"v\", reputation=55, approve=True)]\n>       res = score_appeal({}, votes, threshold=0)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nv13\\tests\\governance\\test_appeals_deterministic.py:45: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nevidence_payload = {}, votes = [Vote(voter_id='v', reputation=55, approve=True, weight=100)], threshold = 0\n\n    def score_appeal(\n        evidence_payload: Dict[str, Any],\n        votes: List[Vote],\n        threshold: int = 5000,  # 50.00 ATR\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Calculate the final score for an appeal.\n    \n        Args:\n            evidence_payload: The raw evidence dictionary.\n            votes: List of cast votes.\n            threshold: Score required for approval (Scale 100).\n    \n        Returns:\n            Dict with 'approved' (bool), 'score' (int), 'hash' (str).\n        \"\"\"\n        # 1. Canonical Hash (The 'Seed')\n        ev_hash = hash_evidence(evidence_payload)\n    \n        # 2. Calculate Tally using CertifiedMath\n        # We use basic integer math here as CertifiedMath wrappers are mainly for\n        # complex funcs (log, exp) or safe division. For additions, standard int matches\n        # Zero-Sim if inputs are integers.\n    \n        score_approve = 0\n        score_reject = 0\n    \n        for v in votes:\n            # Weight = VoteWeight * (Reputation / 100)\n            # Scale: weight(100) * rep(1000) / 100 = 1000.\n            # Use CertifiedMath for division to be safe and consistent.\n    \n            # effective_weight = (v.weight * v.reputation) // 100\n>           effective_weight = CertifiedMath.idiv(v.weight * v.reputation, 100)\n                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           TypeError: CertifiedMath.idiv() missing 1 required positional argument: 'b_int'\n\nv13\\services\\governance\\appeals.py:63: TypeError"}, "hash": "6453aa781c8199aafba0905324b6f8eca7f5679f12f869b052e4b2934bca95ae75683241b5c17b7d1bb80acadfa890f7be6a26d13ef35525b3b284f4b48fbf64"}
{"timestamp": "2025-12-17T09:47:07.085291", "session_id": "c5ed0a32e27a13b0", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/governance/test_appeals_deterministic.py::test_scoring_determinism", "context": {"env": "test"}, "details": {"duration": 0.0002838000073097646, "error": "def test_scoring_determinism():\n        \"\"\"Same votes + same evidence must yield same score.\"\"\"\n        evidence = {\"id\": \"ev_001\", \"content\": \"spam\"}\n        votes = [\n            Vote(voter_id=\"alice\", reputation=1000, approve=True),  # +1000\n            Vote(voter_id=\"bob\", reputation=500, approve=False),  # -500\n        ]\n    \n        # Net = 500. Threshold = 400. -> Approved.\n>       res1 = score_appeal(evidence, votes, threshold=400)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nv13\\tests\\governance\\test_appeals_deterministic.py:21: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nevidence_payload = {'content': 'spam', 'id': 'ev_001'}\nvotes = [Vote(voter_id='alice', reputation=1000, approve=True, weight=100), Vote(voter_id='bob', reputation=500, approve=False, weight=100)], threshold = 400\n\n    def score_appeal(\n        evidence_payload: Dict[str, Any],\n        votes: List[Vote],\n        threshold: int = 5000,  # 50.00 ATR\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Calculate the final score for an appeal.\n    \n        Args:\n            evidence_payload: The raw evidence dictionary.\n            votes: List of cast votes.\n            threshold: Score required for approval (Scale 100).\n    \n        Returns:\n            Dict with 'approved' (bool), 'score' (int), 'hash' (str).\n        \"\"\"\n        # 1. Canonical Hash (The 'Seed')\n        ev_hash = hash_evidence(evidence_payload)\n    \n        # 2. Calculate Tally using CertifiedMath\n        # We use basic integer math here as CertifiedMath wrappers are mainly for\n        # complex funcs (log, exp) or safe division. For additions, standard int matches\n        # Zero-Sim if inputs are integers.\n    \n        score_approve = 0\n        score_reject = 0\n    \n        for v in votes:\n            # Weight = VoteWeight * (Reputation / 100)\n            # Scale: weight(100) * rep(1000) / 100 = 1000.\n            # Use CertifiedMath for division to be safe and consistent.\n    \n            # effective_weight = (v.weight * v.reputation) // 100\n>           effective_weight = CertifiedMath.idiv(v.weight * v.reputation, 100)\n                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           TypeError: CertifiedMath.idiv() missing 1 required positional argument: 'b_int'\n\nv13\\services\\governance\\appeals.py:63: TypeError"}, "hash": "6c5c76017adc2b8d3a2132a16fe8d1f5792d4f4dda101c3d5e35d9a2295e2af87121cfa7018f63ea2fcef7bdec517021532e1bf6d3424e1e4a8ea3e8214d0dd5"}
{"timestamp": "2025-12-17T09:47:07.091677", "session_id": "c5ed0a32e27a13b0", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/governance/test_appeals_deterministic.py::test_scoring_threshold_failure", "context": {"env": "test"}, "details": {"duration": 0.00024679998750798404, "error": "def test_scoring_threshold_failure():\n        \"\"\"Net score below threshold -> Rejected.\"\"\"\n        evidence = {\"id\": \"ev_002\"}\n        votes = [\n            Vote(voter_id=\"alice\", reputation=200, approve=True)  # +200\n        ]\n    \n>       res = score_appeal(evidence, votes, threshold=500)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nv13\\tests\\governance\\test_appeals_deterministic.py:36: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nevidence_payload = {'id': 'ev_002'}, votes = [Vote(voter_id='alice', reputation=200, approve=True, weight=100)], threshold = 500\n\n    def score_appeal(\n        evidence_payload: Dict[str, Any],\n        votes: List[Vote],\n        threshold: int = 5000,  # 50.00 ATR\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Calculate the final score for an appeal.\n    \n        Args:\n            evidence_payload: The raw evidence dictionary.\n            votes: List of cast votes.\n            threshold: Score required for approval (Scale 100).\n    \n        Returns:\n            Dict with 'approved' (bool), 'score' (int), 'hash' (str).\n        \"\"\"\n        # 1. Canonical Hash (The 'Seed')\n        ev_hash = hash_evidence(evidence_payload)\n    \n        # 2. Calculate Tally using CertifiedMath\n        # We use basic integer math here as CertifiedMath wrappers are mainly for\n        # complex funcs (log, exp) or safe division. For additions, standard int matches\n        # Zero-Sim if inputs are integers.\n    \n        score_approve = 0\n        score_reject = 0\n    \n        for v in votes:\n            # Weight = VoteWeight * (Reputation / 100)\n            # Scale: weight(100) * rep(1000) / 100 = 1000.\n            # Use CertifiedMath for division to be safe and consistent.\n    \n            # effective_weight = (v.weight * v.reputation) // 100\n>           effective_weight = CertifiedMath.idiv(v.weight * v.reputation, 100)\n                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           TypeError: CertifiedMath.idiv() missing 1 required positional argument: 'b_int'\n\nv13\\services\\governance\\appeals.py:63: TypeError"}, "hash": "7c3525099bd896be56cc24cfb09cd92dc4d554623b36f6951f6f95afe83e1b17fe48447b54d54c6afa542c4444c662209ac452ffd8f61fd803ead959cab8a814"}
{"timestamp": "2025-12-17T09:47:07.097413", "session_id": "c5ed0a32e27a13b0", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/governance/test_appeals_deterministic.py::test_rounding_safety", "context": {"env": "test"}, "details": {"duration": 0.00020939999376423657, "error": "def test_rounding_safety():\n        \"\"\"Verify integer division behavior via CertifiedMath.\"\"\"\n        # Weight 100 * Rep 55 // 100 = 55\n        votes = [Vote(voter_id=\"v\", reputation=55, approve=True)]\n>       res = score_appeal({}, votes, threshold=0)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nv13\\tests\\governance\\test_appeals_deterministic.py:45: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nevidence_payload = {}, votes = [Vote(voter_id='v', reputation=55, approve=True, weight=100)], threshold = 0\n\n    def score_appeal(\n        evidence_payload: Dict[str, Any],\n        votes: List[Vote],\n        threshold: int = 5000,  # 50.00 ATR\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Calculate the final score for an appeal.\n    \n        Args:\n            evidence_payload: The raw evidence dictionary.\n            votes: List of cast votes.\n            threshold: Score required for approval (Scale 100).\n    \n        Returns:\n            Dict with 'approved' (bool), 'score' (int), 'hash' (str).\n        \"\"\"\n        # 1. Canonical Hash (The 'Seed')\n        ev_hash = hash_evidence(evidence_payload)\n    \n        # 2. Calculate Tally using CertifiedMath\n        # We use basic integer math here as CertifiedMath wrappers are mainly for\n        # complex funcs (log, exp) or safe division. For additions, standard int matches\n        # Zero-Sim if inputs are integers.\n    \n        score_approve = 0\n        score_reject = 0\n    \n        for v in votes:\n            # Weight = VoteWeight * (Reputation / 100)\n            # Scale: weight(100) * rep(1000) / 100 = 1000.\n            # Use CertifiedMath for division to be safe and consistent.\n    \n            # effective_weight = (v.weight * v.reputation) // 100\n>           effective_weight = CertifiedMath.idiv(v.weight * v.reputation, 100)\n                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE           TypeError: CertifiedMath.idiv() missing 1 required positional argument: 'b_int'\n\nv13\\services\\governance\\appeals.py:63: TypeError"}, "hash": "65715ca95eafd045e9734c77c04a50b499c23855a681c5b7330d35924403fa28c2aac18a56e9d4547167998b37211d9a7fbebf2868127aee6262589e6876979c"}
{"timestamp": "2025-12-17T10:01:48.478062", "session_id": "095391b92398d917", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/observability/test_trace_propagation.py::test_trace_propagation_end_to_end", "context": {"env": "test"}, "details": {"duration": 0.04574899998260662, "error": "client = <starlette.testclient.TestClient object at 0x00000168EE86BA10>, capsys = <_pytest.capture.CaptureFixture object at 0x00000168EFA60590>\n\n    def test_trace_propagation_end_to_end(client, capsys):\n        \"\"\"\n        Verify that X-Trace-Id header propagates to CertifiedMath logs.\n        \"\"\"\n        trace_id = \"test-trace-12345\"\n    \n        # Make request\n        response = client.get(\n            \"/explain/reward/test_wallet?epoch=1\", headers={\"x-trace-id\": trace_id}\n        )\n    \n>       assert response.status_code == 200\nE       assert 500 == 200\nE        +  where 500 = <Response [500 Internal Server Error]>.status_code\n\nv13\\tests\\observability\\test_trace_propagation.py:62: AssertionError"}, "hash": "2b774a94b531616eb62264a97f10fa033afb845c3ac06b47a56edaa6d516f8fcffadb3fa5bdd45e9bf6cf923cb068df04ff56c3ef5d48019f099d5e099a771df"}
{"timestamp": "2025-12-17T10:01:48.490565", "session_id": "095391b92398d917", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/observability/test_trace_propagation.py::test_trace_propagation_no_header", "context": {"env": "test"}, "details": {"duration": 0.004688399989390746, "error": "client = <starlette.testclient.TestClient object at 0x00000168EFA66490>, capsys = <_pytest.capture.CaptureFixture object at 0x00000168EFA65BD0>\n\n    def test_trace_propagation_no_header(client, capsys):\n        \"\"\"\n        Verify that a new trace ID is generated if header is missing.\n        \"\"\"\n        response = client.get(\"/explain/reward/test_wallet?epoch=1\")\n>       assert response.status_code == 200\nE       assert 500 == 200\nE        +  where 500 = <Response [500 Internal Server Error]>.status_code\n\nv13\\tests\\observability\\test_trace_propagation.py:100: AssertionError"}, "hash": "9bd63c850f61edca03f0288b40a486a314c4802ef68ab138c4392ad75477490b3d29d5b1cc6c40ac7fddbb47ac049d28ee89ae682b1a84c23d5be790dbfe9493"}
{"timestamp": "2025-12-17T10:08:15.910800", "session_id": "8993fd712f5cb026", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_pqc_provider.py::test_mock_provider_signing_roundtrip", "context": {"env": "test"}, "details": {"duration": 0.00024009999469853938, "error": "def test_mock_provider_signing_roundtrip():\n        \"\"\"Verify sign/verify mechanics for MockProvider.\"\"\"\n        provider = get_pqc_provider()\n        seed = b\"test_seed_signing_123456789032\"\n>       pk, sk = provider.generate_keypair(seed)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nv13\\tests\\unit\\test_pqc_provider.py:31: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <v13.libs.pqc_provider.DeterministicMockProvider object at 0x000002C777127ED0>, seed = b'test_seed_signing_123456789032'\n\n    def generate_keypair(self, seed: bytes) -> Tuple[bytes, bytes]:\n        if not isinstance(seed, bytes) or len(seed) < 32:\n>           raise ValueError(\"Seed must be at least 32 bytes\")\nE           ValueError: Seed must be at least 32 bytes\n\nv13\\libs\\pqc_provider.py:77: ValueError"}, "hash": "bb43cbb9d02b11f3ddf450385e14d0e800934bfa1fec65a20f2cc8fd4726d02ab8d0b3c4358c3603aa34687ac1d41f6ae69cdd456f1d0bf2096c2c829d95ed09"}
{"timestamp": "2025-12-17T10:08:37.061226", "session_id": "da382666d63188f8", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_pqc_provider.py::test_mock_provider_signing_roundtrip", "context": {"env": "test"}, "details": {"duration": 0.00020779998158104718, "error": "def test_mock_provider_signing_roundtrip():\n        \"\"\"Verify sign/verify mechanics for MockProvider.\"\"\"\n        provider = get_pqc_provider()\n        seed = b\"test_seed_signing_123456789032\"\n>       pk, sk = provider.generate_keypair(seed)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nv13\\tests\\unit\\test_pqc_provider.py:31: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <v13.libs.pqc_provider.DeterministicMockProvider object at 0x0000027FADBEBED0>, seed = b'test_seed_signing_123456789032'\n\n    def generate_keypair(self, seed: bytes) -> Tuple[bytes, bytes]:\n        if not isinstance(seed, bytes) or len(seed) < 32:\n>           raise ValueError(\"Seed must be at least 32 bytes\")\nE           ValueError: Seed must be at least 32 bytes\n\nv13\\libs\\pqc_provider.py:77: ValueError"}, "hash": "5e81c079a5e3a896ceb7c3d0c6d9027b48393f8fa093eab71e1081f419232167ff7d0b4ca571712705d0c9ed7367ac88cb97dac96b0275794147fa3e8ea71995"}
{"timestamp": "2025-12-17T10:11:07.586030", "session_id": "a510f9d569b78944", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_system_creator_wallet.py::test_derive_creator_keypair_dev", "context": {"env": "test"}, "details": {"duration": 0.0022037000162526965, "error": "def test_derive_creator_keypair_dev():\n        priv, addr = derive_creator_keypair(\"DEV\")\n>       assert addr == EXPECTED_ADDRESS_DEV\nE       AssertionError: assert '0x86d65da5b0...edcaa7143b4fc' == '0x40d1b50e2b...10e9995d72dc9'\nE         \nE         \u001b[0m\u001b[91m- 0x40d1b50e2b950b1e933b286108335ce73553af2a16b338d408210e9995d72dc9\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\nE         \u001b[92m+ 0x86d65da5b0edd2528e3c6de5506cb0b89ee7b51459d4e4c8768edcaa7143b4fc\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\nv13\\tests\\unit\\test_system_creator_wallet.py:22: AssertionError"}, "hash": "ab7bfcfffc95662a72621a8f830f03330e694b49330a54b4d963673497f25e20d111aa09a0f70ea8a3a625efead0cf03a7cea5f0ca2f89f9fcedeef9745ad4e9"}
{"timestamp": "2025-12-17T10:24:36.154897", "session_id": "facfa44f5cb04f03", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_hd_derivation.py::test_vector_1_hardened_child", "context": {"env": "test"}, "details": {"duration": 0.006907900009537116, "error": "def test_vector_1_hardened_child():\n        seed = bytes.fromhex(SEED_HEX)\n        master = HDKey.from_seed(seed)\n    \n        # Derive m/0' (Index 0 + 0x80000000)\n        child = master.derive(0 + 0x80000000)\n    \n        assert child.key.hex() == M_0H_PRIV_HEX\n>       assert child.chain_code.hex() == M_0H_CHAIN_HEX\nE       AssertionError: assert '47fdacbd0f10...82c7ae6236141' == '47fdacbd3f10...09e92979bff1b'\nE         \nE         \u001b[0m\u001b[91m- 47fdacbd3f106a2e04705146450d163e3fb231d55e9621e25cc09e92979bff1b\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\nE         \u001b[92m+ 47fdacbd0f1097043b78c63c20c34ef4ed9a111d980047ad16282c7ae6236141\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\nv13\\tests\\unit\\test_hd_derivation.py:35: AssertionError"}, "hash": "5b2bc9d3a3d19c8809aa87601078268c41786119936f29d8a7494b003e452b83b5d97e7a9ca116176110fd6f50f4acb17af34a2fe63e11d590830901f81e5638"}
{"timestamp": "2025-12-17T10:25:01.802429", "session_id": "113495d4ca1abed9", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_hd_derivation.py::test_vector_1_hardened_child", "context": {"env": "test"}, "details": {"duration": 0.001363499992294237, "error": "def test_vector_1_hardened_child():\n        seed = bytes.fromhex(SEED_HEX)\n        master = HDKey.from_seed(seed)\n    \n        # Derive m/0' (Index 0 + 0x80000000)\n        child = master.derive(0 + 0x80000000)\n    \n        assert child.key.hex() == M_0H_PRIV_HEX\n>       assert child.chain_code.hex() == M_0H_CHAIN_HEX\nE       AssertionError: assert '47fdacbd0f10...82c7ae6236141' == '47fdacbd3f10...09e92979bff1b'\nE         \nE         \u001b[0m\u001b[91m- 47fdacbd3f106a2e04705146450d163e3fb231d55e9621e25cc09e92979bff1b\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\nE         \u001b[92m+ 47fdacbd0f1097043b78c63c20c34ef4ed9a111d980047ad16282c7ae6236141\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\nv13\\tests\\unit\\test_hd_derivation.py:35: AssertionError"}, "hash": "ebfd21780f36f208ed10ad3837d31e3a2c71cd601c58f49320ac573971bcff71ba5137631e4c735f00cbd0dca37a0d4b49528d3390e76edd68cbc1b60513c8f3"}
{"timestamp": "2025-12-17T10:26:53.685851", "session_id": "bc5d883a8e641b29", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_hd_derivation.py::test_vector_1_hardened_child", "context": {"env": "test"}, "details": {"duration": 0.0012244000099599361, "error": "def test_vector_1_hardened_child():\n        seed = bytes.fromhex(SEED_HEX)\n        master = HDKey.from_seed(seed)\n    \n        # Derive m/0' (Index 0 + 0x80000000)\n        child = master.derive(0 + 0x80000000)\n    \n        assert child.key.hex() == M_0H_PRIV_HEX\n>       assert child.chain_code.hex() == M_0H_CHAIN_HEX\nE       AssertionError: assert '47fdacbd0f10...82c7ae6236141' == '47fdacbd0f10...09e92979bff1b'\nE         \nE         \u001b[0m\u001b[91m- 47fdacbd0f106a2e04705146450d163e3fb231d55e9621e25cc09e92979bff1b\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\nE         \u001b[92m+ 47fdacbd0f1097043b78c63c20c34ef4ed9a111d980047ad16282c7ae6236141\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\nv13\\tests\\unit\\test_hd_derivation.py:35: AssertionError"}, "hash": "77e9d271045f307405ba82cf8a5bfa1a46c517058a9691090e8751e0fa397ef417b8f71ec65ceacc423cdade0d3d524c95c7ccae18a4ebd9a7eb90346084a034"}
{"timestamp": "2025-12-17T10:27:18.581937", "session_id": "e38a99b4484c81ca", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_hd_derivation.py::test_vector_1_hardened_child", "context": {"env": "test"}, "details": {"duration": 0.0012920000008307397, "error": "def test_vector_1_hardened_child():\n        seed = bytes.fromhex(SEED_HEX)\n        master = HDKey.from_seed(seed)\n    \n        # Derive m/0' (Index 0 + 0x80000000)\n        child = master.derive(0 + 0x80000000)\n    \n        assert child.key.hex() == M_0H_PRIV_HEX\n>       assert child.chain_code.hex() == M_0H_CHAIN_HEX\nE       AssertionError: assert '47fdacbd0f10...82c7ae6236141' == '47fdacbd0f10...09e92979bff1b'\nE         \nE         \u001b[0m\u001b[91m- 47fdacbd0f106a2e04705146450d163e3fb231d55e9621e25cc09e92979bff1b\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\nE         \u001b[92m+ 47fdacbd0f1097043b78c63c20c34ef4ed9a111d980047ad16282c7ae6236141\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\nv13\\tests\\unit\\test_hd_derivation.py:35: AssertionError"}, "hash": "dab4202e1567cdc14c6058357838a5e998b29fee3e6c04acbfda339e7f19e83a83e880a7c5eb6c2b28303aa08836793efb5df8285d64a2a06e3fd47c44a4bcf5"}
{"timestamp": "2025-12-17T10:28:05.097077", "session_id": "2b7563079999bee5", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_system_creator_wallet.py::test_derive_creator_keypair_dev", "context": {"env": "test"}, "details": {"duration": 0.09286699999938719, "error": "def test_derive_creator_keypair_dev():\n        priv, addr = derive_creator_keypair(\"DEV\")\n>       assert addr == EXPECTED_ADDRESS_DEV\nE       AssertionError: assert '0x7f63e288dd...ee812b00e3d7f' == '0x86d65da5b0...edcaa7143b4fc'\nE         \nE         \u001b[0m\u001b[91m- 0x86d65da5b0edd2528e3c6de5506cb0b89ee7b51459d4e4c8768edcaa7143b4fc\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\nE         \u001b[92m+ 0x7f63e288dd4775ca540298e7e6de6169b2eec1f281c6949a1c2ee812b00e3d7f\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\nv13\\tests\\unit\\test_system_creator_wallet.py:26: AssertionError"}, "hash": "e40a071883adf32fa1c1c6fe40e68673f05aa21748953730abd55fd0149ba999c2f51855dd156ebe82d7e272a300927e162de8875b47007af33c57f596a7f0db"}
{"timestamp": "2025-12-17T10:28:23.186712", "session_id": "b5a89918e9b71376", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_system_creator_wallet.py::test_derive_creator_keypair_dev", "context": {"env": "test"}, "details": {"duration": 0.09323890000814572, "error": "def test_derive_creator_keypair_dev():\n        priv, addr = derive_creator_keypair(\"DEV\")\n>       assert addr == EXPECTED_ADDRESS_DEV\nE       AssertionError: assert '0x7f63e288dd...ee812b00e3d7f' == '0x86d65da5b0...edcaa7143b4fc'\nE         \nE         \u001b[0m\u001b[91m- 0x86d65da5b0edd2528e3c6de5506cb0b89ee7b51459d4e4c8768edcaa7143b4fc\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\nE         \u001b[92m+ 0x7f63e288dd4775ca540298e7e6de6169b2eec1f281c6949a1c2ee812b00e3d7f\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\nv13\\tests\\unit\\test_system_creator_wallet.py:26: AssertionError"}, "hash": "026c816d379232dc38d2e956bb9299ee227969f1a09ab814b215909701ada9161c65432595a086af70b7b44c2cb371ba9ce35a30545f80ff0d9d00d989c78be7"}
{"timestamp": "2025-12-17T10:29:22.633304", "session_id": "b748b454a030cd27", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/unit/test_system_creator_wallet.py::test_derive_creator_keypair_testnet", "context": {"env": "test"}, "details": {"duration": 0.09478710000985302, "error": "def test_derive_creator_keypair_testnet():\n        priv, addr = derive_creator_keypair(\"TESTNET\")\n>       assert addr != EXPECTED_ADDRESS_DEV\nE       AssertionError: assert '0x7f63e288dd4775ca540298e7e6de6169b2eec1f281c6949a1c2ee812b00e3d7f' != '0x7f63e288dd4775ca540298e7e6de6169b2eec1f281c6949a1c2ee812b00e3d7f'\n\nv13\\tests\\unit\\test_system_creator_wallet.py:32: AssertionError"}, "hash": "456fb46440f189537d84b9d694a21e9049440756be14c003fc58cc324696ef009f29083bb45d6d6d88e4253c7ef846e5eb3be4d39406886fcb427760db47d3f5"}
{"timestamp": "2025-12-17T11:28:44.919297", "session_id": "cbc73ea1f559fe4d", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/sessions/test_session_cutover_boundary.py::test_session_replay_with_multiple_operations", "context": {"env": "test"}, "details": {"duration": 0.0009089999948628247, "error": "def test_session_replay_with_multiple_operations():\n        \"\"\"Test session replay with multiple operations including rotation and revocation.\"\"\"\n        # Create fake ledger\n        ledger = FakeLedger()\n    \n        # Create session manager\n        session_manager = SessionManager(ledger)\n    \n        # Test data\n        wallet_id = \"wallet_123\"\n        device_id = \"device_456\"\n        scope = [\"read\", \"write\"]\n    \n        # Create initial session at block 100\n        token1 = session_manager.create_session(\n            wallet_id=wallet_id,\n            device_id=device_id,\n            scope=scope,\n            current_block=100,\n            ttl_blocks=1000\n        )\n    \n        # Rotate session at block 150\n        token2 = session_manager.rotate_session(token1, 150)\n    \n        # Rotate again at block 200\n        token3 = session_manager.rotate_session(token2, 200)\n    \n        # Revoke at block 250\n        session_manager.revoke_session(token3, \"timeout\", 250)\n    \n        # Verify we have all events\n>       assert len(ledger.events) == 4  # SESSION_STARTED + 2 SESSION_ROTATED + SESSION_REVOKED\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       AssertionError: assert 6 == 4\nE        +  where 6 = len([{'data': {'device_id': 'device_456', 'issued_at_block': 100, 'scope': ['read', 'write'], 'session_id': 'ccc9a4437566ae2daaf9f45e9761e5d2a2ea7a2d871e540e7a479be47ae0eb92', ...}, 'event_type': 'SESSION_STARTED'}, {'data': {'device_id': 'device_456', 'issued_at_block': 150, 'scope': ['read', 'write'], 'session_id': '4da5be2b47b65fdc5e6bac6bce4d0e26401ef322e4309d7dee04b051de40754d', ...}, 'event_type': 'SESSION_STARTED'}, {'data': {'block': 150, 'new_session_id': '4da5be2b47b65fdc5e6bac6bce4d0e26401ef322e4309d7dee04b051de40754d', 'old_session_id': 'ccc9a4437566ae2daaf9f45e9761e5d2a2ea7a2d871e540e7a479be47ae0eb92'}, 'event_type': 'SESSION_ROTATED'}, {'data': {'device_id': 'device_456', 'issued_at_block': 200, 'scope': ['read', 'write'], 'session_id': '0f8102bcdaeea4b6c0c106612133a9ea0480c6f87b26bd7644b088b8c4bf91f8', ...}, 'event_type': 'SESSION_STARTED'}, {'data': {'block': 200, 'new_session_id': '0f8102bcdaeea4b6c0c106612133a9ea0480c6f87b26bd7644b088b8c4bf91f8', 'old_session_id': '4da5be2b47b65fdc5e6bac6bce4d0e26401ef322e4309d7dee04b051de40754d'}, 'event_type': 'SESSION_ROTATED'}, {'data': {'block': 250, 'reason': 'timeout', 'session_id': '0f8102bcdaeea4b6c0c106612133a9ea0480c6f87b26bd7644b088b8c4bf91f8'}, 'event_type': 'SESSION_REVOKED'}])\nE        +    where [{'data': {'device_id': 'device_456', 'issued_at_block': 100, 'scope': ['read', 'write'], 'session_id': 'ccc9a4437566ae2daaf9f45e9761e5d2a2ea7a2d871e540e7a479be47ae0eb92', ...}, 'event_type': 'SESSION_STARTED'}, {'data': {'device_id': 'device_456', 'issued_at_block': 150, 'scope': ['read', 'write'], 'session_id': '4da5be2b47b65fdc5e6bac6bce4d0e26401ef322e4309d7dee04b051de40754d', ...}, 'event_type': 'SESSION_STARTED'}, {'data': {'block': 150, 'new_session_id': '4da5be2b47b65fdc5e6bac6bce4d0e26401ef322e4309d7dee04b051de40754d', 'old_session_id': 'ccc9a4437566ae2daaf9f45e9761e5d2a2ea7a2d871e540e7a479be47ae0eb92'}, 'event_type': 'SESSION_ROTATED'}, {'data': {'device_id': 'device_456', 'issued_at_block': 200, 'scope': ['read', 'write'], 'session_id': '0f8102bcdaeea4b6c0c106612133a9ea0480c6f87b26bd7644b088b8c4bf91f8', ...}, 'event_type': 'SESSION_STARTED'}, {'data': {'block': 200, 'new_session_id': '0f8102bcdaeea4b6c0c106612133a9ea0480c6f87b26bd7644b088b8c4bf91f8', 'old_session_id': '4da5be2b47b65fdc5e6bac6bce4d0e26401ef322e4309d7dee04b051de40754d'}, 'event_type': 'SESSION_ROTATED'}, {'data': {'block': 250, 'reason': 'timeout', 'session_id': '0f8102bcdaeea4b6c0c106612133a9ea0480c6f87b26bd7644b088b8c4bf91f8'}, 'event_type': 'SESSION_REVOKED'}] = <test_session_cutover_boundary.FakeLedger object at 0x0000025A15A95550>.events\n\nv13\\tests\\sessions\\test_session_cutover_boundary.py:54: AssertionError"}, "hash": "6556dc444bc07424ed3317d09fa530ef3eeafb9dd309bbcc7848573980db908b6ef8cf04e0853293345da15dc8af26d9a60e51d79b1a0c78a3bb8dc239ea0250"}
{"timestamp": "2025-12-17T11:28:44.931647", "session_id": "cbc73ea1f559fe4d", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/sessions/test_session_explainability_mixed_eras.py::test_session_explainability_with_rotation", "context": {"env": "test"}, "details": {"duration": 0.0009330000029876828, "error": "def test_session_explainability_with_rotation():\n        \"\"\"Test session explainability with session rotation events.\"\"\"\n        # Create an action event\n        action_event = {\n            \"event_id\": \"action_789\",\n            \"event_type\": \"REFERRAL_USED\",\n            \"block_number\": 2000,\n            \"creator_id\": \"wallet_123\",\n            \"data\": {\n                \"wallet_id\": \"wallet_123\",\n                \"device_id\": \"device_789\",\n                \"referral_code\": \"REF123\"\n            }\n        }\n    \n        # Create session events including rotation\n        session_events = [\n            {\n                \"event_type\": \"SESSION_STARTED\",\n                \"data\": {\n                    \"session_id\": \"session_old\",\n                    \"wallet_id\": \"wallet_123\",\n                    \"device_id\": \"device_789\",\n                    \"issued_at_block\": 1500,\n                    \"ttl_blocks\": 1000,\n                    \"scope\": [\"basic\"]\n                }\n            },\n            {\n                \"event_type\": \"SESSION_ROTATED\",\n                \"data\": {\n                    \"old_session_id\": \"session_old\",\n                    \"new_session_id\": \"session_new\",\n                    \"block\": 1800\n                }\n            }\n        ]\n    \n        # Build proof\n        proof = build_session_proof(action_event, session_events, era_cutoff_block=1000)\n    \n        # Verify proof identifies the rotated session\n        assert proof[\"wallet_id\"] == \"wallet_123\"\n        assert proof[\"device_id\"] == \"device_789\"\n>       assert proof[\"session_id\"] == \"session_new\"  # Should identify the new session\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       AssertionError: assert 'session_old' == 'session_new'\nE         \nE         \u001b[0m\u001b[91m- session_new\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\nE         \u001b[92m+ session_old\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\nv13\\tests\\sessions\\test_session_explainability_mixed_eras.py:153: AssertionError"}, "hash": "1f6bdfc96c6473f123f124c3b3e3f38fa35f076e5e2229e6f63941d40a0140828715eb29a6567ee744b101a4f8b287bbe412ad926a6c4f1d3299b60553da2a76"}
{"timestamp": "2025-12-17T11:28:44.942981", "session_id": "cbc73ea1f559fe4d", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/sessions/test_session_lifecycle_replay.py::test_session_lifecycle_replay", "context": {"env": "test"}, "details": {"duration": 0.0004564999835565686, "error": "def test_session_lifecycle_replay():\n        \"\"\"Test session lifecycle with replay functionality.\"\"\"\n        # Create fake ledger\n        ledger = FakeLedger()\n    \n        # Create session manager\n        session_manager = SessionManager(ledger)\n    \n        # Test data\n        wallet_id = \"wallet_123\"\n        device_id = \"device_456\"\n        scope = [\"read\", \"write\"]\n        current_block = 100\n        ttl_blocks = 1000\n    \n        # Create session\n        token = session_manager.create_session(\n            wallet_id=wallet_id,\n            device_id=device_id,\n            scope=scope,\n            current_block=current_block,\n            ttl_blocks=ttl_blocks\n        )\n    \n        # Verify session token\n        assert token.wallet_id == wallet_id\n        assert token.device_id == device_id\n        assert token.scope == scope\n        assert token.issued_at_block == current_block\n        assert token.ttl_blocks == ttl_blocks\n    \n        # Verify event was emitted\n        assert len(ledger.events) == 1\n        event = ledger.events[0]\n        assert event[\"event_type\"] == \"SESSION_STARTED\"\n        assert event[\"data\"][\"session_id\"] == token.session_id\n        assert event[\"data\"][\"wallet_id\"] == wallet_id\n        assert event[\"data\"][\"device_id\"] == device_id\n    \n        # Rotate session\n        current_block = 150\n        new_token = session_manager.rotate_session(token, current_block)\n    \n        # Verify new token\n        assert new_token.wallet_id == wallet_id\n        assert new_token.device_id == device_id\n        assert new_token.session_id != token.session_id  # Should be different\n        assert new_token.issued_at_block == current_block\n    \n        # Verify events were emitted\n>       assert len(ledger.events) == 2\nE       AssertionError: assert 3 == 2\nE        +  where 3 = len([{'data': {'device_id': 'device_456', 'issued_at_block': 100, 'scope': ['read', 'write'], 'session_id': 'ccc9a4437566ae2daaf9f45e9761e5d2a2ea7a2d871e540e7a479be47ae0eb92', ...}, 'event_type': 'SESSION_STARTED'}, {'data': {'device_id': 'device_456', 'issued_at_block': 150, 'scope': ['read', 'write'], 'session_id': '4da5be2b47b65fdc5e6bac6bce4d0e26401ef322e4309d7dee04b051de40754d', ...}, 'event_type': 'SESSION_STARTED'}, {'data': {'block': 150, 'new_session_id': '4da5be2b47b65fdc5e6bac6bce4d0e26401ef322e4309d7dee04b051de40754d', 'old_session_id': 'ccc9a4437566ae2daaf9f45e9761e5d2a2ea7a2d871e540e7a479be47ae0eb92'}, 'event_type': 'SESSION_ROTATED'}])\nE        +    where [{'data': {'device_id': 'device_456', 'issued_at_block': 100, 'scope': ['read', 'write'], 'session_id': 'ccc9a4437566ae2daaf9f45e9761e5d2a2ea7a2d871e540e7a479be47ae0eb92', ...}, 'event_type': 'SESSION_STARTED'}, {'data': {'device_id': 'device_456', 'issued_at_block': 150, 'scope': ['read', 'write'], 'session_id': '4da5be2b47b65fdc5e6bac6bce4d0e26401ef322e4309d7dee04b051de40754d', ...}, 'event_type': 'SESSION_STARTED'}, {'data': {'block': 150, 'new_session_id': '4da5be2b47b65fdc5e6bac6bce4d0e26401ef322e4309d7dee04b051de40754d', 'old_session_id': 'ccc9a4437566ae2daaf9f45e9761e5d2a2ea7a2d871e540e7a479be47ae0eb92'}, 'event_type': 'SESSION_ROTATED'}] = <test_session_lifecycle_replay.FakeLedger object at 0x0000025A15A96270>.events\n\nv13\\tests\\sessions\\test_session_lifecycle_replay.py:72: AssertionError"}, "hash": "081fcd703470c599f45530d23b6b090e0e3a1568d2da550beb33297546ec95317fbb0fc6f21af2e1b76e675d578329647fb195402a22d45a912276eb7f2bc014"}
{"timestamp": "2025-12-17T11:28:44.955835", "session_id": "cbc73ea1f559fe4d", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/sessions/test_session_rotation_ordering.py::test_session_rotation_emits_correct_event", "context": {"env": "test"}, "details": {"duration": 0.0003657999914139509, "error": "def test_session_rotation_emits_correct_event():\n        \"\"\"Test that session rotation emits the correct ledger event.\"\"\"\n        # Create fake ledger\n        ledger = FakeLedger()\n    \n        # Create session manager\n        session_manager = SessionManager(ledger)\n    \n        # Create initial session\n        wallet_id = \"wallet_123\"\n        device_id = \"device_456\"\n        scope = [\"basic\"]\n        initial_block = 100\n        ttl_blocks = 1000\n    \n        initial_token = session_manager.create_session(\n            wallet_id=wallet_id,\n            device_id=device_id,\n            scope=scope,\n            current_block=initial_block,\n            ttl_blocks=ttl_blocks\n        )\n    \n        # Clear events to focus on rotation event\n        ledger.events.clear()\n    \n        # Rotate session\n        rotation_block = 150\n        rotated_token = session_manager.rotate_session(initial_token, rotation_block)\n    \n        # Verify exactly one event was emitted\n>       assert len(ledger.events) == 1\nE       AssertionError: assert 2 == 1\nE        +  where 2 = len([{'data': {'device_id': 'device_456', 'issued_at_block': 150, 'scope': ['basic'], 'session_id': 'f5aa2578dd37dbde70bf27379d0893955f2e0f5b5da3044595dd0405809f78af', ...}, 'event_type': 'SESSION_STARTED'}, {'data': {'block': 150, 'new_session_id': 'f5aa2578dd37dbde70bf27379d0893955f2e0f5b5da3044595dd0405809f78af', 'old_session_id': '894344490922576df3d933ccd3886ee22826f8870f10475bfb6ca995a9e1001b'}, 'event_type': 'SESSION_ROTATED'}])\nE        +    where [{'data': {'device_id': 'device_456', 'issued_at_block': 150, 'scope': ['basic'], 'session_id': 'f5aa2578dd37dbde70bf27379d0893955f2e0f5b5da3044595dd0405809f78af', ...}, 'event_type': 'SESSION_STARTED'}, {'data': {'block': 150, 'new_session_id': 'f5aa2578dd37dbde70bf27379d0893955f2e0f5b5da3044595dd0405809f78af', 'old_session_id': '894344490922576df3d933ccd3886ee22826f8870f10475bfb6ca995a9e1001b'}, 'event_type': 'SESSION_ROTATED'}] = <test_session_rotation_ordering.FakeLedger object at 0x0000025A15BD47D0>.events\n\nv13\\tests\\sessions\\test_session_rotation_ordering.py:132: AssertionError"}, "hash": "02ce50ab697d63e55314b41933924b88bc6859c4b6075cd18e67fb52c42676a42426a509aca1b709e553c58a683b4bb171ed677675b83fa6ae86830061b7a170"}
{"timestamp": "2025-12-17T11:29:52.399332", "session_id": "0b8ab43b1bf74ecd", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/sessions/test_session_cutover_boundary.py::test_session_replay_with_multiple_operations", "context": {"env": "test"}, "details": {"duration": 0.00042940001003444195, "error": "def test_session_replay_with_multiple_operations():\n        \"\"\"Test session replay with multiple operations including rotation and revocation.\"\"\"\n        # Create fake ledger\n        ledger = FakeLedger()\n    \n        # Create session manager\n        session_manager = SessionManager(ledger)\n    \n        # Test data\n        wallet_id = \"wallet_123\"\n        device_id = \"device_456\"\n        scope = [\"read\", \"write\"]\n    \n        # Create initial session at block 100\n        token1 = session_manager.create_session(\n            wallet_id=wallet_id,\n            device_id=device_id,\n            scope=scope,\n            current_block=100,\n            ttl_blocks=1000\n        )\n    \n        # Rotate session at block 150\n        token2 = session_manager.rotate_session(token1, 150)\n    \n        # Rotate again at block 200\n        token3 = session_manager.rotate_session(token2, 200)\n    \n        # Revoke at block 250\n        session_manager.revoke_session(token3, \"timeout\", 250)\n    \n        # Verify we have all events\n        assert len(ledger.events) == 4  # SESSION_STARTED + 2 SESSION_ROTATED + SESSION_REVOKED\n    \n        # Test replay functionality\n        session_states = replay_sessions(ledger.events)\n    \n        # After revoke, no sessions should exist\n        assert len(session_states) == 0\n    \n        # Test replay at intermediate points\n        # Replay only first event (session created)\n        session_states_1 = replay_sessions(ledger.events[:1])\n        assert len(session_states_1) == 1\n        assert token1.session_id in session_states_1\n    \n        # Replay first two events (session created + first rotation)\n        session_states_2 = replay_sessions(ledger.events[:2])\n>       assert len(session_states_2) == 1  # Only the new session should exist\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       assert 0 == 1\nE        +  where 0 = len({})\n\nv13\\tests\\sessions\\test_session_cutover_boundary.py:70: AssertionError"}, "hash": "91a77a38fdc0dbe891b0c4f2ba6485665908ec6c8e75c702a32c8c2a661ada36c468858c9c3c9cce082c6b10cac4478a9cf3cb15654d79576cda72b29792cab1"}
{"timestamp": "2025-12-17T11:30:35.605169", "session_id": "c044b76e7a8208af", "component": "pytest_session", "level": "ERROR", "category": "testing", "message": "Test Failed: v13/tests/sessions/test_session_explainability_mixed_eras.py::test_session_explainability_with_rotation", "context": {"env": "test"}, "details": {"duration": 0.0009725999843794852, "error": "def test_session_explainability_with_rotation():\n        \"\"\"Test session explainability with session rotation events.\"\"\"\n        # Create an action event\n        action_event = {\n            \"event_id\": \"action_789\",\n            \"event_type\": \"REFERRAL_USED\",\n            \"block_number\": 2000,\n            \"creator_id\": \"wallet_123\",\n            \"data\": {\n                \"wallet_id\": \"wallet_123\",\n                \"device_id\": \"device_789\",\n                \"referral_code\": \"REF123\"\n            }\n        }\n    \n        # Create session events including rotation\n        session_events = [\n            {\n                \"event_type\": \"SESSION_STARTED\",\n                \"data\": {\n                    \"session_id\": \"session_old\",\n                    \"wallet_id\": \"wallet_123\",\n                    \"device_id\": \"device_789\",\n                    \"issued_at_block\": 1500,\n                    \"ttl_blocks\": 1000,\n                    \"scope\": [\"basic\"]\n                }\n            },\n            {\n                \"event_type\": \"SESSION_ROTATED\",\n                \"data\": {\n                    \"old_session_id\": \"session_old\",\n                    \"new_session_id\": \"session_new\",\n                    \"block\": 1800\n                }\n            }\n        ]\n    \n        # Build proof\n        proof = build_session_proof(action_event, session_events, era_cutoff_block=1000)\n    \n        # Verify proof identifies the rotated session\n        assert proof[\"wallet_id\"] == \"wallet_123\"\n        assert proof[\"device_id\"] == \"device_789\"\n>       assert proof[\"session_id\"] == \"session_new\"  # Should identify the new session\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nE       AssertionError: assert 'session_old' == 'session_new'\nE         \nE         \u001b[0m\u001b[91m- session_new\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\nE         \u001b[92m+ session_old\u001b[39;49;00m\u001b[90m\u001b[39;49;00m\n\nv13\\tests\\sessions\\test_session_explainability_mixed_eras.py:153: AssertionError"}, "hash": "55bc0b183f58b7bc3c1bf2b4e56d8dc72c20ceb074db4bc18d8f4e5b2b7716b0aa4effce8d6ea2835a6776df64b1a3c84f836a620c7da02362257ebd6de8c31c"}
