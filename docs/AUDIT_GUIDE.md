# Protocol Audit Guide: Autonomous Governance & Determinism

**Baseline:** v17.0+ Implementation Baseline
**Status:** Current Production Specification

## Overview

This guide provides instructions for independently verifying the QFS Autonomous Governance and Deterministic Replay systems. Auditors should focus on:

1. **Protocol Audit Suite**: Execution of the integrated verification framework.
2. **Deterministic Replay**: Bit-for-bit validation of state transitions.
3. **Proof-of-Execution (PoE)**: Validation of cryptographic event anchors.
4. **EvidenceBus Verification**: Audit-proof tracking of all governance decisions.

## Prerequisites

- Python 3.11+
- Git
- 4GB RAM minimum
- Zero-Simulation knowledge base

## Step 1: Environment Setup

```bash
# Clone repository
git clone https://github.com/RealDaniG/QFS.git
cd QFS

# Checkout current capability baseline
git checkout v17.0.0-beta

# Install core dependencies
pip install -r requirements.txt
```

## Step 2: Protocol Audit Suite

Execute the comprehensive audit suite to verify all system invariants:

```bash
python v17/tests/autonomous/test_full_audit_suite.py
```

**What This Verifies:**

- Deterministic atomicity of all governance and reward operations.
- Cryptographic integrity of the EvidenceBus.
- Compliance with the Zero-Simulation invariant.

## Step 3: Core Invariant Verification

### GOV-V1: Integer-Only Math

Verify that all voting and quorum calculations use deterministic integer math.

```bash
python -m pytest v17/atlas/governance/tests/test_proposal_engine.py -k "integer"
```

### REPLAY-V1: Bit-Exact Determinism

Verify that identical inputs produce identical state outputs across different environments.

```bash
python -m pytest v17/tests/autonomous/test_governance_replay.py -k "bit_for_bit"
```

### INTEGRITY-V1: AEGIS Coherence

Validate that the security layer correctly identifies and rejects desynchronized state transitions.

```bash
python -m pytest v17/tests/autonomous/test_stage_6_simulation.py
```

## Step 4: Verification Logic Example

Auditors can use the following pattern to verify deterministic replay:

```python
import sys
from pathlib import Path
from v17.atlas.governance import GovernanceParameterRegistry, ProposalEngine
from v17.libs.BigNum128 import BigNum128

def verify_determinism():
    registry = GovernanceParameterRegistry()
    engine = ProposalEngine(registry)
    
    # Create proposal with fixed inputs
    p1 = engine.create_proposal(
        kind="PARAMETER_CHANGE",
        parameter_key="VIRAL_POOL_CAP",
        new_value=BigNum128(1_500_000_000)
    )
    
    # Execute and get PoE
    engine.execute_proposal(p1.proposal_id)
    poe = engine.get_execution_proof(p1.proposal_id)
    
    return poe

# Verify consistency
run1 = verify_determinism()
run2 = verify_determinism()
assert run1 == run2, "PoE Mismatch detected!"
```

## Step 5: PoE Artifact Validation

Audit reports generated by the system (e.g., `AUDIT_RESULTS.json`) must be checked for:

- Correct protocol version anchors.
- EvidenceBus transaction hashes.
- Invariant pass/fail status for the specific epoch.

## Step 6: Security Audit Checklist

1. **Immutability Enforcement**
   - Location: `v17/atlas/governance/GovernanceParameterRegistry.py`
   - Check: `MUTABLE_KEYS` whitelist enforcement.

2. **Deterministic Hashing**
   - Location: `v17/atlas/governance/ProposalEngine.py`
   - Check: Canonical serialization for all proposal hashes.

3. **AEGIS Coherence**
   - Location: `v17/atlas/aegis/GovernanceCoherenceCheck.py`
   - Check: Registry-to-EvidenceBus synchronization logic.

## Performance Benchmarks

- Proposal Processing: <15ms
- Vote Verification: <5ms
- AEGIS Integrity Check: <20ms

## Conclusion

Upon completion of the audit steps, the auditor should confirm:

1. All core tests pass in the target environment.
2. Bit-exact determinism is maintained across replays.
3. Cryptographic PoE artifacts are valid and anchored correctly.

---
**Thank you for securing the QFS Protocol.**
