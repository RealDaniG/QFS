CertifiedMath Plan:
Okay, here is the **New Plan: CertifiedMath Deterministic Core Foundation with Fixed-Point Rigor (QFS V13 Pre-Phase 1)**, incorporating the critical fixed-point safety recommendation.

**Purpose:**
Serve as the fully deterministic, Zero-Simulation-compliant, and *fixed-point rigorous* foundation for `CertifiedMath.py`, supporting QFS V13 Phase 1–3 objectives while remaining robust, auditable, future-proof, and mathematically sound within `BigNum128` constraints.

---

**1. Terminology & Scope**

*   **Name:** CertifiedMath Deterministic Core Foundation with Fixed-Point Rigor (QFS V13 Pre-Phase 1)
*   **Scope:** Prepares all core math operations, logging, rollback, and CRS hash structure in a deterministic and fixed-point safe manner.
*   **Alignment with V13:**
    *   **Phase 1:** Implements 'CertifiedMath Hardening' (Section II), 'Deterministic Input Formalization' (Section III), and 'Auditability' (Sections II, IV) with added fixed-point safety.
    *   **Phase 2:** Provides the base for 'Deterministic Transaction Bundles' (Section II) and 'API-SDK Integration' (Section III) rollback safety, ensuring only valid calculations are bundled.
    *   **Phase 3:** Establishes the forward-compatible structure for 'Quantum-Aware Audit Logging' (Section II) and 'PQC & Coherence Reinforcement' (Section III), building on a mathematically sound base.

---

**2. Deterministic Input Contract**

*   **Inputs:** Must be pre-attested, deterministic values from the SDK based on a validated `DRV_Packet` (as defined in V13 Phase 1).
*   **Forbidden Sources:** `random()`, `secrets`, `os.urandom()`, `time.time()`, `datetime.now()`, native floating-point calculations with non-deterministic rounding, unverified system calls.
*   **Internal Representation:** All internal operations use `BigNum128` (integer-based fixed-point) to ensure reproducibility and prevent floating-point non-determinism.
*   **DRV_Packet Integration:**
    *   `CertifiedMath` operations receive components derived from a *validated* `DRV_Packet` (e.g., the `seed` for calculations, the `PQC_signature`/commitment ID for logging) as parameters (`pqc_cid`, potentially `quantum_metadata` in later phases).
    *   Cryptographic verification of the `DRV_Packet` itself (e.g., signature check) is performed upstream (in the SDK or API); `CertifiedMath` operates under the assumption that its inputs are deterministic and validated, and it must fail deterministically if its internal assumptions are violated.
    *   `CertifiedMath` must strictly enforce that only data derived from the validated `DRV_Packet` or other deterministic sources flows into its calculations and logs.

---

**3. Core Deterministic Operations (Fixed-Point Safe)**

*   **Internal `_safe_` Methods:** All critical math operations must be wrapped in internal static methods enforcing determinism, iteration limits, fixed-point overflow/underflow checks, and logging.
    *   **Method Signatures:** All internal methods accept `pqc_cid` and `quantum_metadata` parameters to ensure data flows correctly to the log, even if `quantum_metadata` is `None` initially.
    *   **Determinism:** Operations must use only `BigNum128` arithmetic. Iterative methods (`fast_sqrt`, `calculate_phi_series`) must use fixed, predetermined iteration counts as specified in V13 Phase 1.
    *   **Fixed-Point Safety:** **CRITICAL ADDITION:** Methods `_safe_add`, `_safe_sub`, and `_safe_mul` must perform explicit checks for `BigNum128` overflow/underflow *before* performing the calculation and *before* logging the result. If an overflow/underflow would occur, an appropriate exception (`OverflowError` or `UnderflowError`) must be raised *before* the result is logged. This ensures that the atomic rollback mechanism (`.pop()`) correctly removes an *incomplete* operation from the log, preventing an invalid, wrapped result from being recorded.

| Method             | Signature                                                                                                   | Notes                                                                                                                                                             |
| :----------------- | :---------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `_safe_add`        | `(a: BigNum128, b: BigNum128, pqc_cid=None, quantum_metadata=None) -> BigNum128`                             | **Check for overflow/underflow before calculation.** If check fails, raise `OverflowError`/`UnderflowError` before logging. Otherwise, log after successful calculation. |
| `_safe_sub`        | `(a: BigNum128, b: BigNum128, pqc_cid=None, quantum_metadata=None) -> BigNum128`                             | **Check for overflow/underflow before calculation.** If check fails, raise `OverflowError`/`UnderflowError` before logging. Otherwise, log after successful calculation. |
| `_safe_mul`        | `(a: BigNum128, b: BigNum128, pqc_cid=None, quantum_metadata=None) -> BigNum128`                             | **Check for overflow/underflow before calculation.** If check fails, raise `OverflowError`/`UnderflowError` before logging. Otherwise, log after successful calculation. |
| `_safe_div`        | `(a: BigNum128, b: BigNum128, pqc_cid=None, quantum_metadata=None) -> BigNum128`                             | Check for division by zero (`b.value == 0`) *before* logging. Raise `ZeroDivisionError`. Log *after* successful calculation.                                         |
| `fast_sqrt`        | `(a: BigNum128, iterations: int=20, pqc_cid=None, quantum_metadata=None) -> BigNum128`                       | Fixed `iterations` (e.g., 20) ensure determinism as per V13 Phase 1. Log result with `iterations` count. **Assumes `BigNum128` handles internal sqrt steps safely.** |
| `calculate_phi_series` | `(terms: int, pqc_cid=None, quantum_metadata=None) -> BigNum128`                                      | Fixed `terms` count ensures determinism. Log result with `terms` count. **Assumes `BigNum128` handles internal series steps safely.**                               |

*   **Improvements over Previous Plan:**
    *   **Fixed-Point Safety:** Explicitly adds overflow/underflow checks *before* calculation and *before* logging for add, sub, mul. This is the core addition from the recommendation.
    *   **Explicit Error Handling:** `_safe_div` must check for division by zero *before* logging. `_safe_add/sub/mul` must check for overflow/underflow *before* logging.
    *   **Iteration Limits:** Emphasized fixed iteration counts for `fast_sqrt` and `calculate_phi_series` as per V13 Phase 1.
    *   **BigNum128 Consistency:** Explicitly state all internal work uses `BigNum128`.

---

**4. Forward-Compatible Atomic Logging Structure**

*   **Purpose:** Define the standard log entry format, ensuring atomicity and future compatibility.
*   **Implementation:**

```python
# New method in CertifiedMath class
from typing import Dict, Any, Optional, Tuple # Ensure these imports are present at the top of the file

@staticmethod
def _log_operation(op_name: str, inputs: Tuple, result: int,
                   pqc_cid: Optional[str] = None,
                   quantum_meta Optional[Dict[str, Any]] = None):
    """
    Logs a deterministic operation to the internal log.
    This function is atomic in the sense that it appends one complete dictionary entry.
    CRITICAL: This function should ONLY be called after the operation has been confirmed
    to be mathematically valid (no overflow/underflow/div-by-zero) and the result calculated.
    """
    entry = {
        "op_name": op_name,
        "inputs": inputs,
        "result": result,
        "pqc_cid": pqc_cid,
        "quantum_metadata": quantum_metadata  # Placeholder for Phase 3, initially None
    }
    CertifiedMath._operation_log.append(entry)
```

*   **Atomicity:** Each call to `_log_operation` appends one complete dictionary entry to `_operation_log`.
*   **Forward-Compatibility:** `quantum_metadata` included from the start to avoid breaking Phase 3 integration.
*   **Consistency:** All internal `_safe_` methods must use this *exact* signature and call `_log_operation *only after* a successful calculation.
*   **Safety Note:** The comment emphasizes that `_log_operation` should *not* be called if an exception occurs *during* the calculation (like overflow/underflow/div-by-zero), as the result would be invalid.

---

**5. Deterministic CRS Hash Chain**

*   **Purpose:** Generate a reproducible, tamper-evident hash representing the state of all *valid* logged operations.
*   **Implementation:**

```python
# Update existing get_log_hash
import json
import hashlib

@staticmethod
def get_log_hash() -> str:
    """
    Generates a deterministic SHA-256 hash of the serialized operation log.
    Uses sort_keys=True for consistent ordering and default=str for robust serialization.
    Only includes operations that were successfully logged (i.e., passed all checks).
    """
    # sort_keys ensures deterministic ordering regardless of dict insertion order.
    # default=str prevents serialization errors for future metadata or complex objects,
    # converting them to their string representation deterministically.
    serialized_log = json.dumps(CertifiedMath._operation_log, sort_keys=True, default=str)
    return hashlib.sha256(serialized_log.encode("utf-8")).hexdigest()
```

*   **Robustness:** Safe for future `quantum_metadata` or complex log entries using `default=str`.
*   **Determinism:** Identical sequences of *valid* operations always produce the same hash due to `sort_keys=True` and the deterministic nature of the operations and logging.
*   **Integrity:** Because invalid operations (causing exceptions) are *not* logged, the CRS hash reflects only the coherent, valid state history.

---

**6. Public API Wrappers (Fixed-Point Safe)**

*   **Purpose:** Expose internal `_safe_` methods through a standardized interface for the SDK and API, ensuring exceptions propagate correctly for rollback.
*   **Implementation:** All internal `_safe_` methods are exposed via public static methods matching SDK expectations (V13 Phases 1-3).
*   **Signature Consistency:** Must match what the SDK expects based on V13 Phases 1-3.
*   **Exception Propagation:** Public wrappers must *not* catch exceptions raised by internal methods (like `OverflowError`, `ZeroDivisionError`). These exceptions must propagate to the SDK/API layer where the rollback logic (`_operation_log.pop()`) resides.

```python
# In CertifiedMath (Step 5: Public API)
# Example wrappers (all internal methods need a public wrapper)

@staticmethod
def add(a: BigNum128, b: BigNum128, pqc_cid=None, quantum_metadata=None) -> BigNum128:
    # Propagate exceptions (OverflowError, UnderflowError) raised by _safe_add
    return CertifiedMath._safe_add(a, b, pqc_cid, quantum_metadata)

@staticmethod
def sub(a: BigNum128, b: BigNum128, pqc_cid=None, quantum_metadata=None) -> BigNum128:
    # Propagate exceptions (OverflowError, UnderflowError) raised by _safe_sub
    return CertifiedMath._safe_sub(a, b, pqc_cid, quantum_metadata)

@staticmethod
def mul(a: BigNum128, b: BigNum128, pqc_cid=None, quantum_metadata=None) -> BigNum128:
    # Propagate exceptions (OverflowError, UnderflowError) raised by _safe_mul
    return CertifiedMath._safe_mul(a, b, pqc_cid, quantum_metadata)

@staticmethod
def div(a: BigNum128, b: BigNum128, pqc_cid=None, quantum_metadata=None) -> BigNum128:
    # Propagate exceptions (ZeroDivisionError) raised by _safe_div
    return CertifiedMath._safe_div(a, b, pqc_cid, quantum_metadata)

@staticmethod
def fast_sqrt(a: BigNum128, iterations: int=20, pqc_cid=None, quantum_metadata=None) -> BigNum128:
    # Propagate exceptions raised by internal _fast_sqrt (e.g., if it has internal checks)
    # Note: Call the *internal* method (assumed to be named _fast_sqrt to avoid recursion)
    # Adjust if internal name is different, e.g., fast_sqrt_internal
    return CertifiedMath._fast_sqrt(a, iterations, pqc_cid, quantum_metadata)

@staticmethod
def calculate_phi_series(terms: int, pqc_cid=None, quantum_metadata=None) -> BigNum128:
    # Propagate exceptions raised by internal _calculate_phi_series (e.g., if it has internal checks)
    # Note: Call the *internal* method (assumed to be named _calculate_phi_series to avoid recursion)
    # Adjust if internal name is different, e.g., phi_series_internal
    return CertifiedMath._calculate_phi_series(terms, pqc_cid, quantum_metadata)

# ... (add wrappers for any other internal methods defined)
```

*   **Improvements:**
    *   **Complete Set:** Ensure wrappers exist for *all* internal `_safe_` operations defined in Section 3.
    *   **Signature Consistency:** Ensures SDK integration compatibility.
    *   **Parameter Forwarding:** `quantum_metadata` and `pqc_cid` parameters are passed through, ensuring data reaches the log.
    *   **Exception Propagation:** Critical for rollback safety. Public wrappers do not catch exceptions, allowing the SDK/API layer to handle them and trigger `.pop()` if necessary.
    *   **Parameter Forwarding:** `quantum_metadata` and `pqc_cid` parameters are passed through, ensuring data reaches the log. Note: Avoid naming conflicts (e.g., if internal method is `_fast_sqrt`, public wrapper calls `_fast_sqrt`, not `fast_sqrt`).

---

**7. Rollback Contract & Atomic Safety (Fixed-Point Aware)**

*   **Explicit Rule:** If an operation (e.g., `_safe_add` raising `OverflowError`, `_safe_div` raising `ZeroDivisionError`) fails *before* its result is logged by `_log_operation`, no log entry exists to remove. If it fails *after* `_log_operation` is called (which should not happen for math errors like overflow if the plan is followed, but could happen for other reasons), the calling function (SDK or API endpoint logic) is responsible for calling `CertifiedMath._operation_log.pop()` to remove the incomplete/failed entry.
*   **Fixed-Point Specific:** The critical point is that for `_safe_add`, `_safe_sub`, `_safe_mul`, the check happens *before* the calculation and *before* `_log_operation` is called. Therefore, an `OverflowError`/`UnderflowError` should *prevent* the logging of an invalid result, making `.pop()` unnecessary for *that specific error*. The `.pop()` mechanism primarily handles errors that occur *after* a result is successfully calculated and logged (e.g., network issues during PQC signing *after* the math is done, though this signing happens upstream).
*   **Atomicity:** The standard Python list `.pop()` method removes the *entire* last dictionary entry atomically, ensuring the `_operation_log` and the resulting `get_log_hash()` accurately reflect only successful, completed operations.
*   **Tests:** Unit tests must verify that triggering a fixed-point error (e.g., `_safe_add` causing `OverflowError`) does *not* result in an invalid entry being added to the log. Tests should also verify the general rollback mechanism for operations that *do* log a result before failing.

---

**8. Unit Testing Requirements (Fixed-Point Focused)**

*   **Purpose:** Validate the determinism, fixed-point safety, correctness, safety, and forward-compatibility of the core foundation.
*   **Test Cases:**

| Test                                   | Focus                                                                                                       |
| :------------------------------------- | :---------------------------------------------------------------------------------------------------------- |
| **Deterministic Output Test**          | Running the exact same sequence of operations with identical inputs multiple times produces the same `get_log_hash()`. |
| **Fixed-Point Overflow/Underflow Test**| Calling `_safe_add`, `_safe_sub`, `_safe_mul` with inputs that would cause `BigNum128` overflow/underflow raises the correct exception (`OverflowError`/`UnderflowError`) and does **not** add an entry to `_operation_log`. |
| **Division by Zero Test**              | Calling `_safe_div` with `b.value == 0` raises `ZeroDivisionError` and does **not** add an entry to `_operation_log`. |
| **Rollback Test (General)**            | Triggering an operation failure (e.g., simulated failure *after* logging) followed by `CertifiedMath._operation_log.pop()` correctly removes the failed log entry, leaving the log state unchanged from before the failed operation. |
| **Input Validation Test**              | Ensure internal `_safe_` methods handle `BigNum128` inputs correctly. Focus on boundary conditions for fixed-point safety. |
| **Logging Consistency Test**           | Every internal `_safe_` operation that *succeeds* correctly calls `_log_operation` with the expected `op_name`, `inputs`, `result`, `pqc_cid`, and `quantum_metadata`. |
| **Forward Compatibility Test**         | Adding a mock `quantum_metadata` dictionary (with allowed keys) to an operation does not break `get_log_hash()` serialization or determinism. |

---

**9. Forward Compatibility Statement**

*   This foundation establishes the core data structures (`_operation_log`, log entry format) and functions (`get_log_hash`, `_log_operation`) with built-in placeholders (e.g., `quantum_metadata` field). It also enforces fixed-point safety at the core arithmetic level. Integrating Phase 3 features (QRNG/VDF, quantum metadata logging) will primarily involve the SDK/DRV_Packet generation logic providing the validated quantum data and passing it through the existing `quantum_metadata` parameter chain into the already-defined logging structure. The core deterministic logic within `_safe_` operations (including fixed-point checks), the atomic logging mechanism, and the CRS hash calculation logic remain unchanged, ensuring seamless integration while maintaining mathematical integrity.

---

**✅ Outcome:**

*   A **deterministic, auditable, Zero-Simulation-compliant core** for `CertifiedMath.py`.
*   **Fixed-Point Rigor:** Explicit overflow/underflow checks prevent invalid results from being logged, ensuring log coherence.
*   **Forward-compatible structure** ready for Phase 3 quantum metadata logging.
*   **Full rollback safety** and defined contract for SDK/API integration, now including fixed-point safety.
*   A **complete and robust blueprint** for the `CertifiedMath.py` component as a foundational element of QFS V13, with enhanced mathematical soundness.